From 7e6f317a556e0d8015cdc21585279610c88ac7f7 Mon Sep 17 00:00:00 2001
From: Udit kumar agarwal <dev.madaarigmail.com>
Date: Mon, 2 Jul 2018 02:52:31 +0530
Subject: [PATCH] Updated MMCCAM stack to FreeBSD-head d6756a3ac8

---
 etc/mtree/BSD.include.dist               |    2 +
 include/Makefile                         |    2 +-
 lib/libcam/Makefile                      |    3 +-
 sys/amd64/conf/MMCCAM                    |   36 +
 sys/arm/broadcom/bcm2835/bcm2835_sdhci.c |    4 +
 sys/arm/conf/BEAGLEBONE-MMCCAM           |   21 +
 sys/arm/conf/GENERIC-MMCCAM              |   22 +
 sys/arm/nvidia/tegra_sdhci.c             |    5 +
 sys/arm/ti/ti_sdhci.c                    |   29 +-
 sys/cam/ata/ata_all.c                    |    2 +-
 sys/cam/ata/ata_da.c                     |    6 +-
 sys/cam/ata/ata_pmp.c                    |    2 +-
 sys/cam/ata/ata_xpt.c                    |    4 +-
 sys/cam/cam.h                            |    2 +-
 sys/cam/cam_ccb.h                        |   78 +-
 sys/cam/cam_periph.c                     |   16 +-
 sys/cam/cam_periph.h                     |    2 +-
 sys/cam/cam_xpt.c                        |   18 +-
 sys/cam/cam_xpt.h                        |   13 +
 sys/cam/cam_xpt_internal.h               |    1 +
 sys/cam/mmc/mmc.h                        |  104 ++
 sys/cam/mmc/mmc_all.h                    |   70 ++
 sys/cam/mmc/mmc_bus.h                    |    5 +
 sys/cam/mmc/mmc_da.c                     | 1899 ++++++++++++++++++++++++++++++
 sys/cam/mmc/mmc_xpt.c                    | 1107 +++++++++++++++++
 sys/cam/nvme/nvme_da.c                   |    6 +-
 sys/cam/scsi/scsi_all.c                  |    2 +-
 sys/cam/scsi/scsi_cd.c                   |    3 +-
 sys/cam/scsi/scsi_ch.c                   |    3 +-
 sys/cam/scsi/scsi_da.c                   |    7 +-
 sys/cam/scsi/scsi_enc.c                  |    4 +-
 sys/cam/scsi/scsi_pass.c                 |    5 +-
 sys/cam/scsi/scsi_pt.c                   |    3 +-
 sys/cam/scsi/scsi_sa.c                   |    6 +-
 sys/cam/scsi/scsi_sg.c                   |    3 +-
 sys/cam/scsi/scsi_xpt.c                  |   32 +-
 sys/conf/files                           |    9 +-
 sys/conf/options                         |    2 +
 sys/ddb/db_sym.c                         |    2 +-
 sys/dev/aic7xxx/aic79xx_osm.h            |    2 +-
 sys/dev/aic7xxx/aic7xxx_osm.h            |    2 +-
 sys/dev/drm/drmP.h                       |    2 +-
 sys/dev/isci/environment.h               |    2 +-
 sys/dev/mmc/bridge.h                     |    2 +
 sys/dev/mmc/host/dwmmc.c                 |    4 +
 sys/dev/mmc/host/dwmmc_altera.c          |   95 ++
 sys/dev/mmc/host/dwmmc_rockchip.c        |  152 +++
 sys/dev/mmc/host/dwmmc_samsung.c         |  132 +++
 sys/dev/mmc/mmcbrvar.h                   |    1 -
 sys/dev/mmc/mmcreg.h                     |  102 ++
 sys/dev/sdhci/fsl_sdhci.c                |    5 +
 sys/dev/sdhci/sdhci.c                    |  564 ++++++++-
 sys/dev/sdhci/sdhci.h                    |   14 +
 sys/dev/sdhci/sdhci_acpi.c               |    3 +
 sys/dev/sdhci/sdhci_fdt.c                |   51 +-
 sys/dev/sdhci/sdhci_pci.c                |    8 +-
 sys/modules/sdhci/Makefile               |    2 +-
 usr.bin/sdiotool/Makefile                |    9 +
 usr.bin/sdiotool/brcmfmac_bus.h          |   28 +
 usr.bin/sdiotool/brcmfmac_sdio.h         |  162 +++
 usr.bin/sdiotool/cam_sdio.c              |  440 +++++++
 usr.bin/sdiotool/cam_sdio.h              |   97 ++
 usr.bin/sdiotool/linux_compat.h          |   60 +
 usr.bin/sdiotool/linux_sdio_compat.c     |  104 ++
 usr.bin/sdiotool/linux_sdio_compat.h     |   65 +
 usr.bin/sdiotool/sdiotool.c              |  649 ++++++++++
 66 files changed, 6195 insertions(+), 102 deletions(-)
 create mode 100644 sys/amd64/conf/MMCCAM
 create mode 100644 sys/arm/conf/BEAGLEBONE-MMCCAM
 create mode 100644 sys/arm/conf/GENERIC-MMCCAM
 create mode 100644 sys/cam/mmc/mmc.h
 create mode 100644 sys/cam/mmc/mmc_all.h
 create mode 100644 sys/cam/mmc/mmc_bus.h
 create mode 100644 sys/cam/mmc/mmc_da.c
 create mode 100644 sys/cam/mmc/mmc_xpt.c
 create mode 100644 sys/dev/mmc/host/dwmmc_altera.c
 create mode 100644 sys/dev/mmc/host/dwmmc_rockchip.c
 create mode 100644 sys/dev/mmc/host/dwmmc_samsung.c
 create mode 100644 usr.bin/sdiotool/Makefile
 create mode 100644 usr.bin/sdiotool/brcmfmac_bus.h
 create mode 100644 usr.bin/sdiotool/brcmfmac_sdio.h
 create mode 100644 usr.bin/sdiotool/cam_sdio.c
 create mode 100644 usr.bin/sdiotool/cam_sdio.h
 create mode 100644 usr.bin/sdiotool/linux_compat.h
 create mode 100644 usr.bin/sdiotool/linux_sdio_compat.c
 create mode 100644 usr.bin/sdiotool/linux_sdio_compat.h
 create mode 100644 usr.bin/sdiotool/sdiotool.c

diff --git a/etc/mtree/BSD.include.dist b/etc/mtree/BSD.include.dist
index 15e9807ea73..5383841c3b2 100644
--- a/etc/mtree/BSD.include.dist
+++ b/etc/mtree/BSD.include.dist
@@ -90,6 +90,8 @@
     cam
         ata
         ..
+        mmc
+        ..
         nvme
         ..
         scsi
diff --git a/include/Makefile b/include/Makefile
index e8ad0030a7c..170d6fa35de 100644
--- a/include/Makefile
+++ b/include/Makefile
@@ -42,7 +42,7 @@ LHDRS=	aio.h errno.h fcntl.h linker_set.h poll.h stdatomic.h stdint.h \
 LDIRS=	bsm cam geom net net80211 netgraph netinet netinet6 \
 	netipsec netnatm netsmb nfs nfsclient nfsserver sys vm
 
-LSUBDIRS=	cam/ata cam/nvme cam/scsi \
+LSUBDIRS=	cam/ata  cam/mmc cam/nvme cam/scsi \
 	dev/acpica dev/agp dev/an dev/bktr dev/ciss dev/filemon dev/firewire \
 	dev/hwpmc dev/hyperv \
 	dev/ic dev/iicbus dev/io dev/lmc dev/mfi dev/mmc dev/nvme \
diff --git a/lib/libcam/Makefile b/lib/libcam/Makefile
index 3cf1a0d71db..8aac81c60e1 100644
--- a/lib/libcam/Makefile
+++ b/lib/libcam/Makefile
@@ -37,7 +37,8 @@ MLINKS+=	cam.3 cam_open_device.3 \
 		cam_cdbparse.3 buff_encode_visit.3
 
 .PATH:		${SRCTOP}/sys/cam/scsi ${SRCTOP}/sys/cam/ata \
-		${SRCTOP}/sys/cam
+		${SRCTOP}/sys/cam \
+		${SRCTOP}/sys/cam/mmc
 
 CFLAGS+=	-I${.CURDIR} -I${SRCTOP}/sys
 
diff --git a/sys/amd64/conf/MMCCAM b/sys/amd64/conf/MMCCAM
new file mode 100644
index 00000000000..c8bbeb817f5
--- /dev/null
+++ b/sys/amd64/conf/MMCCAM
@@ -0,0 +1,36 @@
+# MMCCAM is the kernel config for doing MMC on CAM development
+# and testing on bhyve
+# $FreeBSD$
+
+include         MINIMAL
+
+ident		MMCCAM
+
+# Access GPT-formatted and labeled root volume
+options         GEOM_PART_GPT
+options         GEOM_LABEL
+
+# UART -- for bhyve console
+device          uart
+
+# kgdb stub
+device          bvmdebug
+
+# VirtIO support, needed for bhyve
+device		virtio			# Generic VirtIO bus (required)
+device		virtio_pci		# VirtIO PCI device
+device		vtnet			# VirtIO Ethernet device
+device		virtio_blk		# VirtIO Block device
+device		virtio_scsi		# VirtIO SCSI device
+device		virtio_balloon		# VirtIO Memory Balloon device
+
+# CAM-specific stuff
+device		pass
+device		scbus
+device		da
+device		mmccam
+
+options	MMCCAM
+# Add CAMDEBUG stuff
+options CAMDEBUG
+options CAM_DEBUG_FLAGS=(CAM_DEBUG_INFO|CAM_DEBUG_PROBE|CAM_DEBUG_PERIPH|CAM_DEBUG_TRACE)
diff --git a/sys/arm/broadcom/bcm2835/bcm2835_sdhci.c b/sys/arm/broadcom/bcm2835/bcm2835_sdhci.c
index 1954b7d40a6..e39d4e6445b 100644
--- a/sys/arm/broadcom/bcm2835/bcm2835_sdhci.c
+++ b/sys/arm/broadcom/bcm2835/bcm2835_sdhci.c
@@ -52,6 +52,8 @@ __FBSDID("$FreeBSD$");
 #include "mmcbr_if.h"
 #include "sdhci_if.h"
 
+#include "opt_mmccam.h"
+
 #include "bcm2835_dma.h"
 #include <arm/broadcom/bcm2835/bcm2835_mbox_prop.h>
 #include "bcm2835_vcbus.h"
@@ -679,4 +681,6 @@ static driver_t bcm_sdhci_driver = {
 DRIVER_MODULE(sdhci_bcm, simplebus, bcm_sdhci_driver, bcm_sdhci_devclass,
     NULL, NULL);
 MODULE_DEPEND(sdhci_bcm, sdhci, 1, 1, 1);
+#ifndef MMCCAM
 MMC_DECLARE_BRIDGE(sdhci_bcm);
+#endif
diff --git a/sys/arm/conf/BEAGLEBONE-MMCCAM b/sys/arm/conf/BEAGLEBONE-MMCCAM
new file mode 100644
index 00000000000..3d83352e79c
--- /dev/null
+++ b/sys/arm/conf/BEAGLEBONE-MMCCAM
@@ -0,0 +1,21 @@
+#
+# BEAGLEBONE-MMCCAM
+#
+# Custom kernel for Beaglebone plus MMCCAM as opposed to the prior MMC stack. It is
+# present to keep it building in tree since it wouldn't work in LINT.
+#
+# $FreeBSD$
+
+include		BEAGLEBONE
+
+# Add CAMDEBUG stuff
+options 	CAMDEBUG
+options 	CAM_DEBUG_FLAGS=(CAM_DEBUG_INFO|CAM_DEBUG_PROBE|CAM_DEBUG_PERIPH|CAM_DEBUG_TRACE)
+
+# pass(4) device
+device		pass
+device		mmccam
+options		MMCCAM
+
+nodevice	mmc
+nodevice	mmcsd
diff --git a/sys/arm/conf/GENERIC-MMCCAM b/sys/arm/conf/GENERIC-MMCCAM
new file mode 100644
index 00000000000..20ca990d1c3
--- /dev/null
+++ b/sys/arm/conf/GENERIC-MMCCAM
@@ -0,0 +1,22 @@
+#
+# GEMERIC-MMCCAM
+#
+# Custom kernel for GENERIC plus MMCCAM as opposed to the prior MMC stack.
+#
+# $FreeBSD$
+
+include		GENERIC
+
+ident		GENERIC-MMCCAM
+
+options		MMCCAM
+
+# Add CAMDEBUG stuff
+options 	CAMDEBUG
+options 	CAM_DEBUG_FLAGS=(CAM_DEBUG_INFO|CAM_DEBUG_PROBE|CAM_DEBUG_PERIPH)
+
+# pass(4) device
+device		pass
+
+nodevice	mmc
+nodevice	mmcsd
diff --git a/sys/arm/nvidia/tegra_sdhci.c b/sys/arm/nvidia/tegra_sdhci.c
index 0e9921fe2d6..66ff2d1e6d9 100644
--- a/sys/arm/nvidia/tegra_sdhci.c
+++ b/sys/arm/nvidia/tegra_sdhci.c
@@ -62,6 +62,8 @@ __FBSDID("$FreeBSD$");
 
 #include "sdhci_if.h"
 
+#include "opt_mmccam.h"
+
 /* Tegra SDHOST controller vendor register definitions */
 #define	SDMMC_VENDOR_CLOCK_CNTRL		0x100
 #define	 VENDOR_CLOCK_CNTRL_CLK_SHIFT			8
@@ -463,5 +465,8 @@ static DEFINE_CLASS_0(sdhci, tegra_sdhci_driver, tegra_sdhci_methods,
     sizeof(struct tegra_sdhci_softc));
 DRIVER_MODULE(sdhci_tegra, simplebus, tegra_sdhci_driver, tegra_sdhci_devclass,
     NULL, NULL);
+#ifndef MMCCAM
 MODULE_DEPEND(sdhci_tegra, sdhci, 1, 1, 1);
 MMC_DECLARE_BRIDGE(sdhci);
+#endif
+
diff --git a/sys/arm/ti/ti_sdhci.c b/sys/arm/ti/ti_sdhci.c
index 6b188ddd072..cb7e9da65c8 100644
--- a/sys/arm/ti/ti_sdhci.c
+++ b/sys/arm/ti/ti_sdhci.c
@@ -39,6 +39,8 @@ __FBSDID("$FreeBSD$");
 #include <sys/rman.h>
 #include <sys/sysctl.h>
 #include <sys/taskqueue.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
 
 #include <machine/bus.h>
 #include <machine/resource.h>
@@ -60,6 +62,8 @@ __FBSDID("$FreeBSD$");
 #include <arm/ti/ti_hwmods.h>
 #include "gpio_if.h"
 
+#include "opt_mmccam.h"
+
 struct ti_sdhci_softc {
 	device_t		dev;
 	struct sdhci_fdt_gpio * gpio;
@@ -122,6 +126,11 @@ static struct ofw_compat_data compat_data[] = {
 #define	  MMCHS_SD_CAPA_VS30		  (1 << 25)
 #define	  MMCHS_SD_CAPA_VS33		  (1 << 24)
 
+/* Forward declarations, CAM-relataed */
+// static void ti_sdhci_cam_poll(struct cam_sim *);
+// static void ti_sdhci_cam_action(struct cam_sim *, union ccb *);
+// static int ti_sdhci_cam_settran_settings(struct ti_sdhci_softc *sc, union ccb *);
+
 static inline uint32_t
 ti_mmchs_read_4(struct ti_sdhci_softc *sc, bus_size_t off)
 {
@@ -241,6 +250,22 @@ ti_sdhci_write_1(device_t dev, struct sdhci_slot *slot, bus_size_t off,
 	struct ti_sdhci_softc *sc = device_get_softc(dev);
 	uint32_t val32;
 
+#ifdef MMCCAM
+	uint32_t newval32;
+	if (off == SDHCI_HOST_CONTROL) {
+		val32 = ti_mmchs_read_4(sc, MMCHS_CON);
+		newval32  = val32;
+		if (val & SDHCI_CTRL_8BITBUS) {
+			device_printf(dev, "Custom-enabling 8-bit bus\n");
+			newval32 |= MMCHS_CON_DW8;
+		} else {
+			device_printf(dev, "Custom-disabling 8-bit bus\n");
+			newval32 &= ~MMCHS_CON_DW8;
+		}
+		if (newval32 != val32)
+			ti_mmchs_write_4(sc, MMCHS_CON, newval32);
+	}
+#endif
 	val32 = RD4(sc, off & ~3);
 	val32 &= ~(0xff << (off & 3) * 8);
 	val32 |= (val << (off & 3) * 8);
@@ -659,7 +684,6 @@ ti_sdhci_attach(device_t dev)
 	bus_generic_attach(dev);
 
 	sdhci_start_slot(&sc->slot);
-
 	return (0);
 
 fail:
@@ -730,4 +754,7 @@ static driver_t ti_sdhci_driver = {
 DRIVER_MODULE(sdhci_ti, simplebus, ti_sdhci_driver, ti_sdhci_devclass, NULL,
     NULL);
 MODULE_DEPEND(sdhci_ti, sdhci, 1, 1, 1);
+
+#ifndef MMCCAM
 MMC_DECLARE_BRIDGE(sdhci_ti);
+#endif
diff --git a/sys/cam/ata/ata_all.c b/sys/cam/ata/ata_all.c
index 34aa704cfb1..1aba70e76a2 100644
--- a/sys/cam/ata/ata_all.c
+++ b/sys/cam/ata/ata_all.c
@@ -30,7 +30,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/param.h>
 
 #ifdef _KERNEL
-#include <opt_scsi.h>
+#include "opt_scsi.h"
 
 #include <sys/systm.h>
 #include <sys/libkern.h>
diff --git a/sys/cam/ata/ata_da.c b/sys/cam/ata/ata_da.c
index a07a7cd8c18..a11b0447919 100644
--- a/sys/cam/ata/ata_da.c
+++ b/sys/cam/ata/ata_da.c
@@ -1060,7 +1060,7 @@ adadump(void *arg, void *virtual, vm_offset_t physical, off_t offset, size_t len
 		xpt_polled_action(&ccb);
 
 		error = cam_periph_error(&ccb,
-		    0, SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+		    0, SF_NO_RECOVERY | SF_NO_RETRY);
 		if ((ccb.ccb_h.status & CAM_DEV_QFRZN) != 0)
 			cam_release_devq(ccb.ccb_h.path, /*relsim_flags*/0,
 			    /*reduction*/0, /*timeout*/0, /*getcount_only*/0);
@@ -1096,7 +1096,7 @@ adadump(void *arg, void *virtual, vm_offset_t physical, off_t offset, size_t len
 		xpt_polled_action(&ccb);
 
 		error = cam_periph_error(&ccb,
-		    0, SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+		    0, SF_NO_RECOVERY | SF_NO_RETRY);
 		if ((ccb.ccb_h.status & CAM_DEV_QFRZN) != 0)
 			cam_release_devq(ccb.ccb_h.path, /*relsim_flags*/0,
 			    /*reduction*/0, /*timeout*/0, /*getcount_only*/0);
@@ -3309,7 +3309,7 @@ adaerror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 	}
 #endif
 
-	return(cam_periph_error(ccb, cam_flags, sense_flags, NULL));
+	return(cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 static void
diff --git a/sys/cam/ata/ata_pmp.c b/sys/cam/ata/ata_pmp.c
index 1b28fdd0338..acd92f7aa74 100644
--- a/sys/cam/ata/ata_pmp.c
+++ b/sys/cam/ata/ata_pmp.c
@@ -595,7 +595,7 @@ pmpdone(struct cam_periph *periph, union ccb *done_ccb)
 	priority = done_ccb->ccb_h.pinfo.priority;
 
 	if ((done_ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
-		if (cam_periph_error(done_ccb, 0, 0, NULL) == ERESTART) {
+		if (cam_periph_error(done_ccb, 0, 0) == ERESTART) {
 			return;
 		} else if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			cam_release_devq(done_ccb->ccb_h.path,
diff --git a/sys/cam/ata/ata_xpt.c b/sys/cam/ata/ata_xpt.c
index 71445e65331..3cf8b65ec9e 100644
--- a/sys/cam/ata/ata_xpt.c
+++ b/sys/cam/ata/ata_xpt.c
@@ -749,8 +749,8 @@ probedone(struct cam_periph *periph, union ccb *done_ccb)
 
 	if ((done_ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
 		if (cam_periph_error(done_ccb,
-		    0, softc->restart ? (SF_NO_RECOVERY | SF_NO_RETRY) : 0,
-		    NULL) == ERESTART) {
+			0, softc->restart ? (SF_NO_RECOVERY | SF_NO_RETRY) : 0
+		    ) == ERESTART) {
 out:
 			/* Drop freeze taken due to CAM_DEV_QFREEZE flag set. */
 			cam_release_devq(path, 0, 0, 0, FALSE);
diff --git a/sys/cam/cam.h b/sys/cam/cam.h
index b0c55e7075f..1308bbedc59 100644
--- a/sys/cam/cam.h
+++ b/sys/cam/cam.h
@@ -32,7 +32,7 @@
 #define _CAM_CAM_H 1
 
 #ifdef _KERNEL
-#include <opt_cam.h>
+#include "opt_cam.h"
 #endif
 
 #include <sys/cdefs.h>
diff --git a/sys/cam/cam_ccb.h b/sys/cam/cam_ccb.h
index 4cfe2e4fa34..8786f3b6d15 100644
--- a/sys/cam/cam_ccb.h
+++ b/sys/cam/cam_ccb.h
@@ -42,6 +42,7 @@
 #include <cam/scsi/scsi_all.h>
 #include <cam/ata/ata_all.h>
 #include <cam/nvme/nvme_all.h>
+#include <cam/mmc/mmc_all.h>
 
 /* General allocation length definitions for CCB structures */
 #define	IOCDBLEN	CAM_MAX_CDBLEN	/* Space for CDB bytes/pointer */
@@ -208,10 +209,10 @@ typedef enum {
 	XPT_NVME_IO		= 0x1c | XPT_FC_DEV_QUEUED,
 				/* Execiute the requestred NVMe I/O operation */
 
-	XPT_MMCSD_IO		= 0x1d | XPT_FC_DEV_QUEUED,
+	XPT_MMC_IO		= 0x1d | XPT_FC_DEV_QUEUED,
 				/* Placeholder for MMC / SD / SDIO I/O stuff */
 
-	XPT_SCAN_TGT		= 0x1E | XPT_FC_QUEUED | XPT_FC_USER_CCB
+	XPT_SCAN_TGT		= 0x1e | XPT_FC_QUEUED | XPT_FC_USER_CCB
 				       | XPT_FC_XPT_ONLY,
 				/* Scan Target */
 
@@ -267,6 +268,7 @@ typedef enum {
 	PROTO_SATAPM,	/* SATA Port Multiplier */
 	PROTO_SEMB,	/* SATA Enclosure Management Bridge */
 	PROTO_NVME,	/* NVME */
+	PROTO_MMCSD,	/* MMC, SD, SDIO */
 } cam_proto;
 
 typedef enum {
@@ -283,6 +285,7 @@ typedef enum {
 	XPORT_ISCSI,	/* iSCSI */
 	XPORT_SRP,	/* SCSI RDMA Protocol */
 	XPORT_NVME,	/* NVMe over PCIe */
+	XPORT_MMCSD,	/* MMC, SD, SDIO card */
 } cam_xport;
 
 #define XPORT_IS_NVME(t)	((t) == XPORT_NVME)
@@ -773,6 +776,16 @@ struct ccb_ataio {
 	uint32_t   unused;
 };
 
+/*
+ * MMC I/O Request CCB used for the XPT_MMC_IO function code.
+ */
+struct ccb_mmcio {
+	struct	   ccb_hdr ccb_h;
+	union	   ccb *next_ccb;	/* Ptr for next CCB for action */
+	struct mmc_command cmd;
+        struct mmc_command stop;
+};
+
 struct ccb_accept_tio {
 	struct	   ccb_hdr ccb_h;
 	cdb_t	   cdb_io;		/* Union for CDB bytes/pointer */
@@ -1005,7 +1018,28 @@ struct ccb_trans_settings_nvme
 	u_int		max_xfer;	/* Max transfer size (0 -> unlimited */
 	u_int		caps;
 };
-	
+
+#include <cam/mmc/mmc_bus.h>
+struct ccb_trans_settings_mmc {
+	struct mmc_ios ios;
+#define MMC_CLK		(1 << 1)
+#define MMC_VDD		(1 << 2)
+#define MMC_CS		(1 << 3)
+#define MMC_BW		(1 << 4)
+#define MMC_PM		(1 << 5)
+#define MMC_BT		(1 << 6)
+#define MMC_BM		(1 << 7)
+	uint32_t ios_valid;
+/* The folowing is used only for GET_TRAN_SETTINGS */
+	uint32_t	host_ocr;
+	int host_f_min;
+	int host_f_max;
+#define MMC_CAP_4_BIT_DATA	(1 << 0) /* Can do 4-bit data transfers */
+#define MMC_CAP_8_BIT_DATA	(1 << 1) /* Can do 8-bit data transfers */
+#define MMC_CAP_HSPEED		(1 << 2) /* Can do High Speed transfers */
+	uint32_t host_caps;
+};
+
 /* Get/Set transfer rate/width/disconnection/tag queueing settings */
 struct ccb_trans_settings {
 	struct	  ccb_hdr ccb_h;
@@ -1019,6 +1053,7 @@ struct ccb_trans_settings {
 		struct ccb_trans_settings_ata ata;
 		struct ccb_trans_settings_scsi scsi;
 		struct ccb_trans_settings_nvme nvme;
+		struct ccb_trans_settings_mmc mmc;
 	} proto_specific;
 	union {
 		u_int  valid;	/* Which fields to honor */
@@ -1227,6 +1262,7 @@ struct ccb_dev_advinfo {
 #define	CDAI_TYPE_PHYS_PATH	3
 #define	CDAI_TYPE_RCAPLONG	4
 #define	CDAI_TYPE_EXT_INQ	5
+#define CDAI_TYPE_MMC_PARAMS	8
 	off_t bufsiz;			/* IN: Size of external buffer */
 #define	CAM_SCSI_DEVID_MAXLEN	65536	/* length in buffer is an uint16_t */
 	off_t provsiz;			/* OUT: Size required/used */
@@ -1284,6 +1320,7 @@ union ccb {
 	struct	ccb_dev_advinfo		cdai;
 	struct	ccb_async		casync;
 	struct	ccb_nvmeio		nvmeio;
+	struct	ccb_mmcio		mmcio;
 };
 
 #define CCB_CLEAR_ALL_EXCEPT_HDR(ccbp)			\
@@ -1326,6 +1363,13 @@ cam_fill_smpio(struct ccb_smpio *smpio, uint32_t retries,
 	       uint8_t *smp_response, int smp_response_len,
 	       uint32_t timeout);
 
+static __inline void
+cam_fill_mmcio(struct ccb_mmcio *mmcio, uint32_t retries,
+	       void (*cbfcnp)(struct cam_periph *, union ccb *), uint32_t flags,
+               uint32_t mmc_opcode, uint32_t mmc_arg, uint32_t mmc_flags,
+	       struct mmc_data *mmc_d,
+	       uint32_t timeout);
+
 static __inline void
 cam_fill_csio(struct ccb_scsiio *csio, u_int32_t retries,
 	      void (*cbfcnp)(struct cam_periph *, union ccb *),
@@ -1414,6 +1458,34 @@ cam_fill_smpio(struct ccb_smpio *smpio, uint32_t retries,
 	smpio->smp_response_len = smp_response_len;
 }
 
+static __inline void
+cam_fill_mmcio(struct ccb_mmcio *mmcio, uint32_t retries,
+	       void (*cbfcnp)(struct cam_periph *, union ccb *), uint32_t flags,
+	       uint32_t mmc_opcode, uint32_t mmc_arg, uint32_t mmc_flags,
+	       struct mmc_data *mmc_d,
+	       uint32_t timeout)
+{
+	mmcio->ccb_h.func_code = XPT_MMC_IO;
+	mmcio->ccb_h.flags = flags;
+	mmcio->ccb_h.retry_count = retries;
+	mmcio->ccb_h.cbfcnp = cbfcnp;
+	mmcio->ccb_h.timeout = timeout;
+	mmcio->cmd.opcode = mmc_opcode;
+	mmcio->cmd.arg = mmc_arg;
+	mmcio->cmd.flags = mmc_flags;
+	mmcio->stop.opcode = 0;
+	mmcio->stop.arg = 0;
+	mmcio->stop.flags = 0;
+	if (mmc_d != NULL) {
+		mmcio->cmd.data = mmc_d;
+	} else
+		mmcio->cmd.data = NULL;
+	mmcio->cmd.resp[0] = 0;
+	mmcio->cmd.resp[1] = 0;
+	mmcio->cmd.resp[2] = 0;
+	mmcio->cmd.resp[3] = 0;
+}
+
 static __inline void
 cam_set_ccbstatus(union ccb *ccb, cam_status status)
 {
diff --git a/sys/cam/cam_periph.c b/sys/cam/cam_periph.c
index b3cbf59e334..c9b0568ef3d 100644
--- a/sys/cam/cam_periph.c
+++ b/sys/cam/cam_periph.c
@@ -810,6 +810,18 @@ cam_periph_mapmem(union ccb *ccb, struct cam_periph_map_info *mapinfo,
 		dirs[0] = ccb->ccb_h.flags & CAM_DIR_MASK;
 		numbufs = 1;
 		break;
+	case XPT_MMC_IO:
+		if ((ccb->ccb_h.flags & CAM_DIR_MASK) == CAM_DIR_NONE)
+			return(0);
+		/* Two mappings: one for cmd->data and one for cmd->data->data */
+		data_ptrs[0] = (unsigned char **)&ccb->mmcio.cmd.data;
+		lengths[0] = sizeof(struct mmc_data *);
+		dirs[0] = ccb->ccb_h.flags & CAM_DIR_MASK;
+		data_ptrs[1] = (unsigned char **)&ccb->mmcio.cmd.data->data;
+		lengths[1] = ccb->mmcio.cmd.data->len;
+		dirs[1] = ccb->ccb_h.flags & CAM_DIR_MASK;
+		numbufs = 2;
+		break;
 	case XPT_SMP_IO:
 		data_ptrs[0] = &ccb->smpio.smp_request;
 		lengths[0] = ccb->smpio.smp_request_len;
@@ -1251,7 +1263,7 @@ camperiphdone(struct cam_periph *periph, union ccb *done_ccb)
 			}
 		}
 		if (cam_periph_error(done_ccb,
-		    0, SF_RETRY_UA | SF_NO_PRINT, NULL) == ERESTART)
+		    0, SF_RETRY_UA | SF_NO_PRINT) == ERESTART)
 			goto out;
 		if (done_ccb->ccb_h.status & CAM_DEV_QFRZN) {
 			cam_release_devq(done_ccb->ccb_h.path, 0, 0, 0, 0);
@@ -1665,7 +1677,7 @@ sense_error_done:
  */
 int
 cam_periph_error(union ccb *ccb, cam_flags camflags,
-		 u_int32_t sense_flags, union ccb *save_ccb)
+		 u_int32_t sense_flags)
 {
 	struct cam_path *newpath;
 	union ccb  *orig_ccb, *scan_ccb;
diff --git a/sys/cam/cam_periph.h b/sys/cam/cam_periph.h
index 87f153c3213..e20a7776f28 100644
--- a/sys/cam/cam_periph.h
+++ b/sys/cam/cam_periph.h
@@ -195,7 +195,7 @@ void		cam_periph_freeze_after_event(struct cam_periph *periph,
 					      struct timeval* event_time,
 					      u_int duration_ms);
 int		cam_periph_error(union ccb *ccb, cam_flags camflags,
-				 u_int32_t sense_flags, union ccb *save_ccb);
+				 u_int32_t sense_flags);
 
 static __inline struct mtx *
 cam_periph_mtx(struct cam_periph *periph)
diff --git a/sys/cam/cam_xpt.c b/sys/cam/cam_xpt.c
index 6be86ce65b8..cd3dac64b88 100644
--- a/sys/cam/cam_xpt.c
+++ b/sys/cam/cam_xpt.c
@@ -326,7 +326,6 @@ static xpt_devicefunc_t	xptsetasyncfunc;
 static xpt_busfunc_t	xptsetasyncbusfunc;
 static cam_status	xptregister(struct cam_periph *periph,
 				    void *arg);
-static const char *	xpt_action_name(uint32_t action);
 static __inline int device_is_queued(struct cam_ed *device);
 
 static __inline int
@@ -409,7 +408,7 @@ xptioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flag, struct thread *td
 	}
 	return (error);
 }
-	
+
 static int
 xptdoioctl(struct cdev *dev, u_long cmd, caddr_t addr, int flag, struct thread *td)
 {
@@ -817,6 +816,8 @@ xpt_scanner_thread(void *dummy)
 			TAILQ_REMOVE(&xsoftc.ccb_scanq, &ccb->ccb_h, sim_links.tqe);
 			xpt_unlock_buses();
 
+                        //printf("xpt_scanner_thread is firing on path ");
+                        //xpt_print_path(ccb->ccb_h.path);printf("\n");
 			/*
 			 * Since lock can be dropped inside and path freed
 			 * by completion callback even before return here,
@@ -1388,7 +1389,7 @@ xptdevicematch(struct dev_match_pattern *patterns, u_int num_patterns,
 
 		cur_pattern = &patterns[i].pattern.device_pattern;
 
-		/* Error out if mutually exclusive options are specified. */ 
+		/* Error out if mutually exclusive options are specified. */
 		if ((cur_pattern->flags & (DEV_MATCH_INQUIRY|DEV_MATCH_DEVID))
 		 == (DEV_MATCH_INQUIRY|DEV_MATCH_DEVID))
 			return(DM_RET_ERROR);
@@ -2575,6 +2576,8 @@ xpt_action_default(union ccb *start_ccb)
 		if (start_ccb->ccb_h.func_code == XPT_NVME_IO)
 			start_ccb->nvmeio.resid = 0;
 		/* FALLTHROUGH */
+	case XPT_MMC_IO:
+		/* XXX just like nmve_io? */
 	case XPT_RESET_DEV:
 	case XPT_ENG_EXEC:
 	case XPT_SMP_IO:
@@ -2686,11 +2689,12 @@ call_sim:
 			mtx_lock(mtx);
 		else
 			mtx = NULL;
+
 		CAM_DEBUG(path, CAM_DEBUG_TRACE,
-		    ("sim->sim_action: func=%#x\n", start_ccb->ccb_h.func_code));
+		    ("Calling sim->sim_action(): func=%#x\n", start_ccb->ccb_h.func_code));
 		(*(sim->sim_action))(sim, start_ccb);
 		CAM_DEBUG(path, CAM_DEBUG_TRACE,
-		    ("sim->sim_action: status=%#x\n", start_ccb->ccb_h.status));
+		    ("sim->sim_action returned: status=%#x\n", start_ccb->ccb_h.status));
 		if (mtx)
 			mtx_unlock(mtx);
 		break;
@@ -5425,7 +5429,7 @@ static struct kv map[] = {
 	{ XPT_GET_SIM_KNOB, "XPT_GET_SIM_KNOB" },
 	{ XPT_SET_SIM_KNOB, "XPT_SET_SIM_KNOB" },
 	{ XPT_NVME_IO, "XPT_NVME_IO" },
-	{ XPT_MMCSD_IO, "XPT_MMCSD_IO" },
+	{ XPT_MMC_IO, "XPT_MMC_IO" },
 	{ XPT_SMP_IO, "XPT_SMP_IO" },
 	{ XPT_SCAN_TGT, "XPT_SCAN_TGT" },
 	{ XPT_ENG_INQ, "XPT_ENG_INQ" },
@@ -5441,7 +5445,7 @@ static struct kv map[] = {
 	{ 0, 0 }
 };
 
-static const char *
+const char *
 xpt_action_name(uint32_t action) 
 {
 	static char buffer[32];	/* Only for unknown messages -- racy */
diff --git a/sys/cam/cam_xpt.h b/sys/cam/cam_xpt.h
index 8e6027e5644..a6523099c83 100644
--- a/sys/cam/cam_xpt.h
+++ b/sys/cam/cam_xpt.h
@@ -34,6 +34,7 @@
 
 #ifdef _KERNEL
 #include <sys/cdefs.h>
+#include <cam/cam_ccb.h>
 #endif
 
 /* Forward Declarations */
@@ -141,6 +142,18 @@ void			xpt_copy_path(struct cam_path *new_path,
 
 void			xpt_release_path(struct cam_path *path);
 
+const char *		xpt_action_name(uint32_t action);
+
+static inline void
+xpt_path_inq(struct ccb_pathinq *cpi, struct cam_path *path)
+{
+
+	bzero(cpi, sizeof(*cpi));
+	xpt_setup_ccb(&cpi->ccb_h, path, CAM_PRIORITY_NORMAL);
+	cpi->ccb_h.func_code = XPT_PATH_INQ;
+	xpt_action((union ccb *)cpi);
+}
+
 #endif /* _KERNEL */
 
 #endif /* _CAM_CAM_XPT_H */
diff --git a/sys/cam/cam_xpt_internal.h b/sys/cam/cam_xpt_internal.h
index b573c81e0b0..b2b84f3997e 100644
--- a/sys/cam/cam_xpt_internal.h
+++ b/sys/cam/cam_xpt_internal.h
@@ -120,6 +120,7 @@ struct cam_ed {
 	uint32_t	 rcap_len;
 	uint8_t		 *rcap_buf;
 	struct		 ata_params ident_data;
+        struct		 mmc_params mmc_ident_data;
 	u_int8_t	 inq_flags;	/*
 					 * Current settings for inquiry flags.
 					 * This allows us to override settings
diff --git a/sys/cam/mmc/mmc.h b/sys/cam/mmc/mmc.h
new file mode 100644
index 00000000000..809c0382d66
--- /dev/null
+++ b/sys/cam/mmc/mmc.h
@@ -0,0 +1,104 @@
+/*-
+ * Copyright (c) 2014-2016 Ilya Bakulin.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Portions of this software may have been developed with reference to
+ * the SD Simplified Specification.  The following disclaimer may apply:
+ *
+ * The following conditions apply to the release of the simplified
+ * specification ("Simplified Specification") by the SD Card Association and
+ * the SD Group. The Simplified Specification is a subset of the complete SD
+ * Specification which is owned by the SD Card Association and the SD
+ * Group. This Simplified Specification is provided on a non-confidential
+ * basis subject to the disclaimers below. Any implementation of the
+ * Simplified Specification may require a license from the SD Card
+ * Association, SD Group, SD-3C LLC or other third parties.
+ *
+ * Disclaimers:
+ *
+ * The information contained in the Simplified Specification is presented only
+ * as a standard specification for SD Cards and SD Host/Ancillary products and
+ * is provided "AS-IS" without any representations or warranties of any
+ * kind. No responsibility is assumed by the SD Group, SD-3C LLC or the SD
+ * Card Association for any damages, any infringements of patents or other
+ * right of the SD Group, SD-3C LLC, the SD Card Association or any third
+ * parties, which may result from its use. No license is granted by
+ * implication, estoppel or otherwise under any patent or other rights of the
+ * SD Group, SD-3C LLC, the SD Card Association or any third party. Nothing
+ * herein shall be construed as an obligation by the SD Group, the SD-3C LLC
+ * or the SD Card Association to disclose or distribute any technical
+ * information, know-how or other confidential information to any third party.
+ *
+ * Inspired coded in sys/dev/mmc. Thanks to Warner Losh <imp@FreeBSD.org>,
+ * Bernd Walter <tisco@FreeBSD.org>, and other authors.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef CAM_MMC_H
+#define CAM_MMC_H
+
+#include <dev/mmc/mmcreg.h>
+/*
+ * This structure describes an MMC/SD card
+ */
+struct mmc_params {
+        u_int8_t	model[40]; /* Card model */
+
+        /* Card OCR */
+        uint32_t card_ocr;
+
+        /* OCR of the IO portion of the card */
+        uint32_t io_ocr;
+
+        /* Card CID -- raw and parsed */
+        uint32_t card_cid[4];
+        struct mmc_cid  cid;
+
+        /* Card CSD -- raw */
+        uint32_t card_csd[4];
+
+        /* Card RCA */
+        uint16_t card_rca;
+
+        /* What kind of card is it */
+        uint32_t card_features;
+#define CARD_FEATURE_MEMORY 0x1
+#define CARD_FEATURE_SDHC   0x1 << 1
+#define CARD_FEATURE_SDIO   0x1 << 2
+#define CARD_FEATURE_SD20   0x1 << 3
+#define CARD_FEATURE_MMC    0x1 << 4
+#define CARD_FEATURE_18V    0x1 << 5
+
+        uint8_t sdio_func_count;
+} __packed;
+
+/*
+ * Only one MMC card on bus is supported now.
+ * If we ever want to support multiple MMC cards on the same bus,
+ * mmc_xpt needs to be extended to issue new RCAs based on number
+ * of already probed cards. Furthermore, retuning and high-speed
+ * settings should also take all cards into account.
+ */
+#define MMC_PROPOSED_RCA    2
+
+#endif
diff --git a/sys/cam/mmc/mmc_all.h b/sys/cam/mmc/mmc_all.h
new file mode 100644
index 00000000000..c2494894ca2
--- /dev/null
+++ b/sys/cam/mmc/mmc_all.h
@@ -0,0 +1,70 @@
+/*-
+ * Copyright (c) 2014-2016 Ilya Bakulin.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Portions of this software may have been developed with reference to
+ * the SD Simplified Specification.  The following disclaimer may apply:
+ *
+ * The following conditions apply to the release of the simplified
+ * specification ("Simplified Specification") by the SD Card Association and
+ * the SD Group. The Simplified Specification is a subset of the complete SD
+ * Specification which is owned by the SD Card Association and the SD
+ * Group. This Simplified Specification is provided on a non-confidential
+ * basis subject to the disclaimers below. Any implementation of the
+ * Simplified Specification may require a license from the SD Card
+ * Association, SD Group, SD-3C LLC or other third parties.
+ *
+ * Disclaimers:
+ *
+ * The information contained in the Simplified Specification is presented only
+ * as a standard specification for SD Cards and SD Host/Ancillary products and
+ * is provided "AS-IS" without any representations or warranties of any
+ * kind. No responsibility is assumed by the SD Group, SD-3C LLC or the SD
+ * Card Association for any damages, any infringements of patents or other
+ * right of the SD Group, SD-3C LLC, the SD Card Association or any third
+ * parties, which may result from its use. No license is granted by
+ * implication, estoppel or otherwise under any patent or other rights of the
+ * SD Group, SD-3C LLC, the SD Card Association or any third party. Nothing
+ * herein shall be construed as an obligation by the SD Group, the SD-3C LLC
+ * or the SD Card Association to disclose or distribute any technical
+ * information, know-how or other confidential information to any third party.
+ *
+ * $FreeBSD$
+ */
+
+/*
+ * MMC function that should be visible to the CAM subsystem
+ * and are somehow useful should be declared here
+ *
+ * Like in other *_all.h, it's also a nice place to include
+ * some other transport-specific headers.
+ */
+
+#ifndef CAM_MMC_ALL_H
+#define CAM_MMC_ALL_H
+
+#include <cam/mmc/mmc.h>
+#include <dev/mmc/mmcreg.h>
+
+void	mmc_print_ident(struct mmc_params *ident_data);
+
+#endif
diff --git a/sys/cam/mmc/mmc_bus.h b/sys/cam/mmc/mmc_bus.h
new file mode 100644
index 00000000000..db77da51078
--- /dev/null
+++ b/sys/cam/mmc/mmc_bus.h
@@ -0,0 +1,5 @@
+/*
+ * This file is in the public domain.
+ * $FreeBSD$
+ */
+#include <dev/mmc/bridge.h>
diff --git a/sys/cam/mmc/mmc_da.c b/sys/cam/mmc/mmc_da.c
new file mode 100644
index 00000000000..aba2b2cb802
--- /dev/null
+++ b/sys/cam/mmc/mmc_da.c
@@ -0,0 +1,1899 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2006 Bernd Walter <tisco@FreeBSD.org>
+ * Copyright (c) 2006 M. Warner Losh <imp@FreeBSD.org>
+ * Copyright (c) 2009 Alexander Motin <mav@FreeBSD.org>
+ * Copyright (c) 2015-2017 Ilya Bakulin <kibab@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Some code derived from the sys/dev/mmc and sys/cam/ata
+ * Thanks to Warner Losh <imp@FreeBSD.org>, Alexander Motin <mav@FreeBSD.org>
+ * Bernd Walter <tisco@FreeBSD.org>, and other authors.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+//#include "opt_sdda.h"
+
+#include <sys/param.h>
+
+#ifdef _KERNEL
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/bio.h>
+#include <sys/endian.h>
+#include <sys/taskqueue.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/conf.h>
+#include <sys/devicestat.h>
+#include <sys/eventhandler.h>
+#include <sys/malloc.h>
+#include <sys/cons.h>
+#include <sys/proc.h>
+#include <sys/reboot.h>
+#include <geom/geom_disk.h>
+#include <machine/_inttypes.h>  /* for PRIu64 */
+#endif /* _KERNEL */
+
+#ifndef _KERNEL
+#include <stdio.h>
+#include <string.h>
+#endif /* _KERNEL */
+
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <cam/cam_queue.h>
+#include <cam/cam_periph.h>
+#include <cam/cam_sim.h>
+#include <cam/cam_xpt.h>
+#include <cam/cam_xpt_sim.h>
+#include <cam/cam_xpt_periph.h>
+#include <cam/cam_xpt_internal.h>
+#include <cam/cam_debug.h>
+
+
+#include <cam/mmc/mmc_all.h>
+
+#include <machine/md_var.h>	/* geometry translation */
+
+#ifdef _KERNEL
+
+typedef enum {
+	SDDA_FLAG_OPEN		= 0x0002,
+	SDDA_FLAG_DIRTY		= 0x0004
+} sdda_flags;
+
+typedef enum {
+	SDDA_STATE_INIT,
+	SDDA_STATE_INVALID,
+	SDDA_STATE_NORMAL,
+	SDDA_STATE_PART_SWITCH,
+} sdda_state;
+
+#define	SDDA_FMT_BOOT		"sdda%dboot"
+#define	SDDA_FMT_GP		"sdda%dgp"
+#define	SDDA_FMT_RPMB		"sdda%drpmb"
+#define	SDDA_LABEL_ENH		"enh"
+
+#define	SDDA_PART_NAMELEN	(16 + 1)
+
+struct sdda_softc;
+
+struct sdda_part {
+	struct disk *disk;
+	struct bio_queue_head bio_queue;
+	sdda_flags flags;
+	struct sdda_softc *sc;
+	u_int cnt;
+	u_int type;
+	bool ro;
+	char name[SDDA_PART_NAMELEN];
+};
+
+struct sdda_softc {
+	int	 outstanding_cmds;	/* Number of active commands */
+	int	 refcount;		/* Active xpt_action() calls */
+	sdda_state state;
+	struct mmc_data *mmcdata;
+	struct cam_periph *periph;
+//	sdda_quirks quirks;
+	struct task start_init_task;
+	uint32_t raw_csd[4];
+	uint8_t raw_ext_csd[512]; /* MMC only? */
+	struct mmc_csd csd;
+	struct mmc_cid cid;
+	struct mmc_scr scr;
+	/* Calculated from CSD */
+	uint64_t sector_count;
+	uint64_t mediasize;
+
+	/* Calculated from CID */
+	char card_id_string[64];/* Formatted CID info (serial, MFG, etc) */
+	char card_sn_string[16];/* Formatted serial # for disk->d_ident */
+	/* Determined from CSD + is highspeed card*/
+	uint32_t card_f_max;
+
+	/* Generic switch timeout */
+	uint32_t cmd6_time;
+	/* MMC partitions support */
+	struct sdda_part *part[MMC_PART_MAX];
+	uint8_t part_curr;	/* Partition currently switched to */
+	uint8_t part_requested; /* What partition we're currently switching to */
+	uint32_t part_time;	/* Partition switch timeout [us] */
+	off_t enh_base;		/* Enhanced user data area slice base ... */
+	off_t enh_size;		/* ... and size [bytes] */
+	int log_count;
+	struct timeval log_time;
+};
+
+#define ccb_bp		ppriv_ptr1
+
+static	disk_strategy_t	sddastrategy;
+static	periph_init_t	sddainit;
+static	void		sddaasync(void *callback_arg, u_int32_t code,
+				struct cam_path *path, void *arg);
+static	periph_ctor_t	sddaregister;
+static	periph_dtor_t	sddacleanup;
+static	periph_start_t	sddastart;
+static	periph_oninv_t	sddaoninvalidate;
+static	void		sddadone(struct cam_periph *periph,
+			       union ccb *done_ccb);
+static  int		sddaerror(union ccb *ccb, u_int32_t cam_flags,
+				u_int32_t sense_flags);
+
+static uint16_t get_rca(struct cam_periph *periph);
+static void sdda_start_init(void *context, union ccb *start_ccb);
+static void sdda_start_init_task(void *context, int pending);
+static void sdda_process_mmc_partitions(struct cam_periph *periph, union ccb *start_ccb);
+static uint32_t sdda_get_host_caps(struct cam_periph *periph, union ccb *ccb);
+static void sdda_init_switch_part(struct cam_periph *periph, union ccb *start_ccb, u_int part);
+static int mmc_select_card(struct cam_periph *periph, union ccb *ccb, uint32_t rca);
+static inline uint32_t mmc_get_sector_size(struct cam_periph *periph) {return MMC_SECTOR_SIZE;}
+
+/* TODO: actually issue GET_TRAN_SETTINGS to get R/O status */
+static inline bool sdda_get_read_only(struct cam_periph *periph, union ccb *start_ccb)
+{
+
+	return (false);
+}
+
+static uint32_t mmc_get_spec_vers(struct cam_periph *periph);
+static uint64_t mmc_get_media_size(struct cam_periph *periph);
+static uint32_t mmc_get_cmd6_timeout(struct cam_periph *periph);
+static void sdda_add_part(struct cam_periph *periph, u_int type,
+    const char *name, u_int cnt, off_t media_size, bool ro);
+
+static struct periph_driver sddadriver =
+{
+	sddainit, "sdda",
+	TAILQ_HEAD_INITIALIZER(sddadriver.units), /* generation */ 0
+};
+
+PERIPHDRIVER_DECLARE(sdda, sddadriver);
+
+static MALLOC_DEFINE(M_SDDA, "sd_da", "sd_da buffers");
+
+static const int exp[8] = {
+	1, 10, 100, 1000, 10000, 100000, 1000000, 10000000
+};
+
+static const int mant[16] = {
+	0, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80
+};
+
+static const int cur_min[8] = {
+	500, 1000, 5000, 10000, 25000, 35000, 60000, 100000
+};
+
+static const int cur_max[8] = {
+	1000, 5000, 10000, 25000, 35000, 45000, 800000, 200000
+};
+
+static uint16_t
+get_rca(struct cam_periph *periph) {
+	return periph->path->device->mmc_ident_data.card_rca;
+}
+
+static uint32_t
+mmc_get_bits(uint32_t *bits, int bit_len, int start, int size)
+{
+	const int i = (bit_len / 32) - (start / 32) - 1;
+	const int shift = start & 31;
+	uint32_t retval = bits[i] >> shift;
+	if (size + shift > 32)
+		retval |= bits[i - 1] << (32 - shift);
+	return (retval & ((1llu << size) - 1));
+}
+
+
+static void
+mmc_decode_csd_sd(uint32_t *raw_csd, struct mmc_csd *csd)
+{
+	int v;
+	int m;
+	int e;
+
+	memset(csd, 0, sizeof(*csd));
+	csd->csd_structure = v = mmc_get_bits(raw_csd, 128, 126, 2);
+	if (v == 0) {
+		m = mmc_get_bits(raw_csd, 128, 115, 4);
+		e = mmc_get_bits(raw_csd, 128, 112, 3);
+		csd->tacc = (exp[e] * mant[m] + 9) / 10;
+		csd->nsac = mmc_get_bits(raw_csd, 128, 104, 8) * 100;
+		m = mmc_get_bits(raw_csd, 128, 99, 4);
+		e = mmc_get_bits(raw_csd, 128, 96, 3);
+		csd->tran_speed = exp[e] * 10000 * mant[m];
+		csd->ccc = mmc_get_bits(raw_csd, 128, 84, 12);
+		csd->read_bl_len = 1 << mmc_get_bits(raw_csd, 128, 80, 4);
+		csd->read_bl_partial = mmc_get_bits(raw_csd, 128, 79, 1);
+		csd->write_blk_misalign = mmc_get_bits(raw_csd, 128, 78, 1);
+		csd->read_blk_misalign = mmc_get_bits(raw_csd, 128, 77, 1);
+		csd->dsr_imp = mmc_get_bits(raw_csd, 128, 76, 1);
+		csd->vdd_r_curr_min = cur_min[mmc_get_bits(raw_csd, 128, 59, 3)];
+		csd->vdd_r_curr_max = cur_max[mmc_get_bits(raw_csd, 128, 56, 3)];
+		csd->vdd_w_curr_min = cur_min[mmc_get_bits(raw_csd, 128, 53, 3)];
+		csd->vdd_w_curr_max = cur_max[mmc_get_bits(raw_csd, 128, 50, 3)];
+		m = mmc_get_bits(raw_csd, 128, 62, 12);
+		e = mmc_get_bits(raw_csd, 128, 47, 3);
+		csd->capacity = ((1 + m) << (e + 2)) * csd->read_bl_len;
+		csd->erase_blk_en = mmc_get_bits(raw_csd, 128, 46, 1);
+		csd->erase_sector = mmc_get_bits(raw_csd, 128, 39, 7) + 1;
+		csd->wp_grp_size = mmc_get_bits(raw_csd, 128, 32, 7);
+		csd->wp_grp_enable = mmc_get_bits(raw_csd, 128, 31, 1);
+		csd->r2w_factor = 1 << mmc_get_bits(raw_csd, 128, 26, 3);
+		csd->write_bl_len = 1 << mmc_get_bits(raw_csd, 128, 22, 4);
+		csd->write_bl_partial = mmc_get_bits(raw_csd, 128, 21, 1);
+	} else if (v == 1) {
+		m = mmc_get_bits(raw_csd, 128, 115, 4);
+		e = mmc_get_bits(raw_csd, 128, 112, 3);
+		csd->tacc = (exp[e] * mant[m] + 9) / 10;
+		csd->nsac = mmc_get_bits(raw_csd, 128, 104, 8) * 100;
+		m = mmc_get_bits(raw_csd, 128, 99, 4);
+		e = mmc_get_bits(raw_csd, 128, 96, 3);
+		csd->tran_speed = exp[e] * 10000 * mant[m];
+		csd->ccc = mmc_get_bits(raw_csd, 128, 84, 12);
+		csd->read_bl_len = 1 << mmc_get_bits(raw_csd, 128, 80, 4);
+		csd->read_bl_partial = mmc_get_bits(raw_csd, 128, 79, 1);
+		csd->write_blk_misalign = mmc_get_bits(raw_csd, 128, 78, 1);
+		csd->read_blk_misalign = mmc_get_bits(raw_csd, 128, 77, 1);
+		csd->dsr_imp = mmc_get_bits(raw_csd, 128, 76, 1);
+		csd->capacity = ((uint64_t)mmc_get_bits(raw_csd, 128, 48, 22) + 1) *
+		    512 * 1024;
+		csd->erase_blk_en = mmc_get_bits(raw_csd, 128, 46, 1);
+		csd->erase_sector = mmc_get_bits(raw_csd, 128, 39, 7) + 1;
+		csd->wp_grp_size = mmc_get_bits(raw_csd, 128, 32, 7);
+		csd->wp_grp_enable = mmc_get_bits(raw_csd, 128, 31, 1);
+		csd->r2w_factor = 1 << mmc_get_bits(raw_csd, 128, 26, 3);
+		csd->write_bl_len = 1 << mmc_get_bits(raw_csd, 128, 22, 4);
+		csd->write_bl_partial = mmc_get_bits(raw_csd, 128, 21, 1);
+	} else
+		panic("unknown SD CSD version");
+}
+
+static void
+mmc_decode_csd_mmc(uint32_t *raw_csd, struct mmc_csd *csd)
+{
+	int m;
+	int e;
+
+	memset(csd, 0, sizeof(*csd));
+	csd->csd_structure = mmc_get_bits(raw_csd, 128, 126, 2);
+	csd->spec_vers = mmc_get_bits(raw_csd, 128, 122, 4);
+	m = mmc_get_bits(raw_csd, 128, 115, 4);
+	e = mmc_get_bits(raw_csd, 128, 112, 3);
+	csd->tacc = exp[e] * mant[m] + 9 / 10;
+	csd->nsac = mmc_get_bits(raw_csd, 128, 104, 8) * 100;
+	m = mmc_get_bits(raw_csd, 128, 99, 4);
+	e = mmc_get_bits(raw_csd, 128, 96, 3);
+	csd->tran_speed = exp[e] * 10000 * mant[m];
+	csd->ccc = mmc_get_bits(raw_csd, 128, 84, 12);
+	csd->read_bl_len = 1 << mmc_get_bits(raw_csd, 128, 80, 4);
+	csd->read_bl_partial = mmc_get_bits(raw_csd, 128, 79, 1);
+	csd->write_blk_misalign = mmc_get_bits(raw_csd, 128, 78, 1);
+	csd->read_blk_misalign = mmc_get_bits(raw_csd, 128, 77, 1);
+	csd->dsr_imp = mmc_get_bits(raw_csd, 128, 76, 1);
+	csd->vdd_r_curr_min = cur_min[mmc_get_bits(raw_csd, 128, 59, 3)];
+	csd->vdd_r_curr_max = cur_max[mmc_get_bits(raw_csd, 128, 56, 3)];
+	csd->vdd_w_curr_min = cur_min[mmc_get_bits(raw_csd, 128, 53, 3)];
+	csd->vdd_w_curr_max = cur_max[mmc_get_bits(raw_csd, 128, 50, 3)];
+	m = mmc_get_bits(raw_csd, 128, 62, 12);
+	e = mmc_get_bits(raw_csd, 128, 47, 3);
+	csd->capacity = ((1 + m) << (e + 2)) * csd->read_bl_len;
+	csd->erase_blk_en = 0;
+	csd->erase_sector = (mmc_get_bits(raw_csd, 128, 42, 5) + 1) *
+	    (mmc_get_bits(raw_csd, 128, 37, 5) + 1);
+	csd->wp_grp_size = mmc_get_bits(raw_csd, 128, 32, 5);
+	csd->wp_grp_enable = mmc_get_bits(raw_csd, 128, 31, 1);
+	csd->r2w_factor = 1 << mmc_get_bits(raw_csd, 128, 26, 3);
+	csd->write_bl_len = 1 << mmc_get_bits(raw_csd, 128, 22, 4);
+	csd->write_bl_partial = mmc_get_bits(raw_csd, 128, 21, 1);
+}
+
+static void
+mmc_decode_cid_sd(uint32_t *raw_cid, struct mmc_cid *cid)
+{
+	int i;
+
+	/* There's no version info, so we take it on faith */
+	memset(cid, 0, sizeof(*cid));
+	cid->mid = mmc_get_bits(raw_cid, 128, 120, 8);
+	cid->oid = mmc_get_bits(raw_cid, 128, 104, 16);
+	for (i = 0; i < 5; i++)
+		cid->pnm[i] = mmc_get_bits(raw_cid, 128, 96 - i * 8, 8);
+	cid->pnm[5] = 0;
+	cid->prv = mmc_get_bits(raw_cid, 128, 56, 8);
+	cid->psn = mmc_get_bits(raw_cid, 128, 24, 32);
+	cid->mdt_year = mmc_get_bits(raw_cid, 128, 12, 8) + 2000;
+	cid->mdt_month = mmc_get_bits(raw_cid, 128, 8, 4);
+}
+
+static void
+mmc_decode_cid_mmc(uint32_t *raw_cid, struct mmc_cid *cid)
+{
+	int i;
+
+	/* There's no version info, so we take it on faith */
+	memset(cid, 0, sizeof(*cid));
+	cid->mid = mmc_get_bits(raw_cid, 128, 120, 8);
+	cid->oid = mmc_get_bits(raw_cid, 128, 104, 8);
+	for (i = 0; i < 6; i++)
+		cid->pnm[i] = mmc_get_bits(raw_cid, 128, 96 - i * 8, 8);
+	cid->pnm[6] = 0;
+	cid->prv = mmc_get_bits(raw_cid, 128, 48, 8);
+	cid->psn = mmc_get_bits(raw_cid, 128, 16, 32);
+	cid->mdt_month = mmc_get_bits(raw_cid, 128, 12, 4);
+	cid->mdt_year = mmc_get_bits(raw_cid, 128, 8, 4) + 1997;
+}
+
+static void
+mmc_format_card_id_string(struct sdda_softc *sc, struct mmc_params *mmcp)
+{
+	char oidstr[8];
+	uint8_t c1;
+	uint8_t c2;
+
+	/*
+	 * Format a card ID string for use by the mmcsd driver, it's what
+	 * appears between the <> in the following:
+	 * mmcsd0: 968MB <SD SD01G 8.0 SN 2686905 Mfg 08/2008 by 3 TN> at mmc0
+	 * 22.5MHz/4bit/128-block
+	 *
+	 * Also format just the card serial number, which the mmcsd driver will
+	 * use as the disk->d_ident string.
+	 *
+	 * The card_id_string in mmc_ivars is currently allocated as 64 bytes,
+	 * and our max formatted length is currently 55 bytes if every field
+	 * contains the largest value.
+	 *
+	 * Sometimes the oid is two printable ascii chars; when it's not,
+	 * format it as 0xnnnn instead.
+	 */
+	c1 = (sc->cid.oid >> 8) & 0x0ff;
+	c2 = sc->cid.oid & 0x0ff;
+	if (c1 > 0x1f && c1 < 0x7f && c2 > 0x1f && c2 < 0x7f)
+		snprintf(oidstr, sizeof(oidstr), "%c%c", c1, c2);
+	else
+		snprintf(oidstr, sizeof(oidstr), "0x%04x", sc->cid.oid);
+	snprintf(sc->card_sn_string, sizeof(sc->card_sn_string),
+	    "%08X", sc->cid.psn);
+	snprintf(sc->card_id_string, sizeof(sc->card_id_string),
+                 "%s%s %s %d.%d SN %08X MFG %02d/%04d by %d %s",
+                 mmcp->card_features & CARD_FEATURE_MMC ? "MMC" : "SD",
+                 mmcp->card_features & CARD_FEATURE_SDHC ? "HC" : "",
+                 sc->cid.pnm, sc->cid.prv >> 4, sc->cid.prv & 0x0f,
+                 sc->cid.psn, sc->cid.mdt_month, sc->cid.mdt_year,
+                 sc->cid.mid, oidstr);
+}
+
+static int
+sddaopen(struct disk *dp)
+{
+	struct sdda_part *part;
+	struct cam_periph *periph;
+	struct sdda_softc *softc;
+	int error;
+
+	part = (struct sdda_part *)dp->d_drv1;
+	softc = part->sc;
+	periph = softc->periph;
+	if (cam_periph_acquire(periph) != CAM_REQ_CMP) {
+		return(ENXIO);
+	}
+
+	cam_periph_lock(periph);
+	if ((error = cam_periph_hold(periph, PRIBIO|PCATCH)) != 0) {
+		cam_periph_unlock(periph);
+		cam_periph_release(periph);
+		return (error);
+	}
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddaopen\n"));
+
+	part->flags |= SDDA_FLAG_OPEN;
+
+	cam_periph_unhold(periph);
+	cam_periph_unlock(periph);
+	return (0);
+}
+
+static int
+sddaclose(struct disk *dp)
+{
+	struct sdda_part *part;
+	struct	cam_periph *periph;
+	struct	sdda_softc *softc;
+
+	part = (struct sdda_part *)dp->d_drv1;
+	softc = part->sc;
+	periph = softc->periph;
+	part->flags &= ~SDDA_FLAG_OPEN;
+
+	cam_periph_lock(periph);
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddaclose\n"));
+
+	while (softc->refcount != 0)
+		cam_periph_sleep(periph, &softc->refcount, PRIBIO, "sddaclose", 1);
+	cam_periph_unlock(periph);
+	cam_periph_release(periph);
+	return (0);
+}
+
+static void
+sddaschedule(struct cam_periph *periph)
+{
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+	struct sdda_part *part;
+	struct bio *bp;
+	int i;
+
+	/* Check if we have more work to do. */
+	/* Find partition that has outstanding commands. Prefer current partition. */
+	bp = bioq_first(&softc->part[softc->part_curr]->bio_queue);
+	if (bp == NULL) {
+		for (i = 0; i < MMC_PART_MAX; i++) {
+			if ((part = softc->part[i]) != NULL &&
+			    (bp = bioq_first(&softc->part[i]->bio_queue)) != NULL)
+				break;
+		}
+	}
+	if (bp != NULL) {
+		xpt_schedule(periph, CAM_PRIORITY_NORMAL);
+	}
+}
+
+/*
+ * Actually translate the requested transfer into one the physical driver
+ * can understand.  The transfer is described by a buf and will include
+ * only one physical transfer.
+ */
+static void
+sddastrategy(struct bio *bp)
+{
+	struct cam_periph *periph;
+	struct sdda_part *part;
+	struct sdda_softc *softc;
+
+	part = (struct sdda_part *)bp->bio_disk->d_drv1;
+	softc = part->sc;
+	periph = softc->periph;
+
+	cam_periph_lock(periph);
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddastrategy(%p)\n", bp));
+
+	/*
+	 * If the device has been made invalid, error out
+	 */
+	if ((periph->flags & CAM_PERIPH_INVALID) != 0) {
+		cam_periph_unlock(periph);
+		biofinish(bp, NULL, ENXIO);
+		return;
+	}
+
+	/*
+	 * Place it in the queue of disk activities for this disk
+	 */
+	bioq_disksort(&part->bio_queue, bp);
+
+	/*
+	 * Schedule ourselves for performing the work.
+	 */
+	sddaschedule(periph);
+	cam_periph_unlock(periph);
+
+	return;
+}
+
+static void
+sddainit(void)
+{
+	cam_status status;
+
+	/*
+	 * Install a global async callback.  This callback will
+	 * receive async callbacks like "new device found".
+	 */
+	status = xpt_register_async(AC_FOUND_DEVICE, sddaasync, NULL, NULL);
+
+	if (status != CAM_REQ_CMP) {
+		printf("sdda: Failed to attach master async callback "
+		       "due to status 0x%x!\n", status);
+	}
+}
+
+/*
+ * Callback from GEOM, called when it has finished cleaning up its
+ * resources.
+ */
+static void
+sddadiskgonecb(struct disk *dp)
+{
+	struct cam_periph *periph;
+	struct sdda_part *part;
+
+	part = (struct sdda_part *)dp->d_drv1;
+	periph = part->sc->periph;
+        CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddadiskgonecb\n"));
+
+	cam_periph_release(periph);
+}
+
+static void
+sddaoninvalidate(struct cam_periph *periph)
+{
+	struct sdda_softc *softc;
+	struct sdda_part *part;
+
+	softc = (struct sdda_softc *)periph->softc;
+
+        CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddaoninvalidate\n"));
+
+	/*
+	 * De-register any async callbacks.
+	 */
+	xpt_register_async(0, sddaasync, periph, periph->path);
+
+	/*
+	 * Return all queued I/O with ENXIO.
+	 * XXX Handle any transactions queued to the card
+	 *     with XPT_ABORT_CCB.
+	 */
+        CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("bioq_flush start\n"));
+	for (int i = 0; i < MMC_PART_MAX; i++) {
+		if ((part = softc->part[i]) != NULL) {
+			bioq_flush(&part->bio_queue, NULL, ENXIO);
+			disk_gone(part->disk);
+		}
+	}
+        CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("bioq_flush end\n"));
+
+}
+
+static void
+sddacleanup(struct cam_periph *periph)
+{
+	struct sdda_softc *softc;
+	struct sdda_part *part;
+	int i;
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddacleanup\n"));
+	softc = (struct sdda_softc *)periph->softc;
+
+	cam_periph_unlock(periph);
+
+	for (i = 0; i < MMC_PART_MAX; i++) {
+		if ((part = softc->part[i]) != NULL) {
+			disk_destroy(part->disk);
+			free(part, M_DEVBUF);
+			softc->part[i] = NULL;
+		}
+	}
+	free(softc, M_DEVBUF);
+	cam_periph_lock(periph);
+}
+
+static void
+sddaasync(void *callback_arg, u_int32_t code,
+	struct cam_path *path, void *arg)
+{
+	struct ccb_getdev cgd;
+	struct cam_periph *periph;
+	struct sdda_softc *softc;
+
+	periph = (struct cam_periph *)callback_arg;
+        CAM_DEBUG(path, CAM_DEBUG_TRACE, ("sddaasync(code=%d)\n", code));
+	switch (code) {
+	case AC_FOUND_DEVICE:
+	{
+                CAM_DEBUG(path, CAM_DEBUG_TRACE, ("=> AC_FOUND_DEVICE\n"));
+		struct ccb_getdev *cgd;
+		cam_status status;
+
+		cgd = (struct ccb_getdev *)arg;
+		if (cgd == NULL)
+			break;
+
+		if (cgd->protocol != PROTO_MMCSD)
+			break;
+
+                if (!(path->device->mmc_ident_data.card_features & CARD_FEATURE_MEMORY)) {
+                        CAM_DEBUG(path, CAM_DEBUG_TRACE, ("No memory on the card!\n"));
+                        break;
+                }
+
+		/*
+		 * Allocate a peripheral instance for
+		 * this device and start the probe
+		 * process.
+		 */
+		status = cam_periph_alloc(sddaregister, sddaoninvalidate,
+					  sddacleanup, sddastart,
+					  "sdda", CAM_PERIPH_BIO,
+					  path, sddaasync,
+					  AC_FOUND_DEVICE, cgd);
+
+		if (status != CAM_REQ_CMP
+		 && status != CAM_REQ_INPROG)
+			printf("sddaasync: Unable to attach to new device "
+				"due to status 0x%x\n", status);
+		break;
+	}
+	case AC_GETDEV_CHANGED:
+	{
+		CAM_DEBUG(path, CAM_DEBUG_TRACE, ("=> AC_GETDEV_CHANGED\n"));
+		softc = (struct sdda_softc *)periph->softc;
+		xpt_setup_ccb(&cgd.ccb_h, periph->path, CAM_PRIORITY_NORMAL);
+		cgd.ccb_h.func_code = XPT_GDEV_TYPE;
+		xpt_action((union ccb *)&cgd);
+		cam_periph_async(periph, code, path, arg);
+		break;
+	}
+	case AC_ADVINFO_CHANGED:
+	{
+		uintptr_t buftype;
+		int i;
+
+		CAM_DEBUG(path, CAM_DEBUG_TRACE, ("=> AC_ADVINFO_CHANGED\n"));
+		buftype = (uintptr_t)arg;
+		if (buftype == CDAI_TYPE_PHYS_PATH) {
+			struct sdda_softc *softc;
+			struct sdda_part *part;
+
+			softc = periph->softc;
+			for (i = 0; i < MMC_PART_MAX; i++) {
+				if ((part = softc->part[i]) != NULL) {
+					disk_attr_changed(part->disk, "GEOM::physpath",
+					    M_NOWAIT);
+				}
+			}
+		}
+		break;
+	}
+	default:
+		CAM_DEBUG(path, CAM_DEBUG_TRACE, ("=> default?!\n"));
+		cam_periph_async(periph, code, path, arg);
+		break;
+	}
+}
+
+
+static int
+sddagetattr(struct bio *bp)
+{
+	struct cam_periph *periph;
+	struct sdda_softc *softc;
+	struct sdda_part *part;
+	int ret;
+
+	part = (struct sdda_part *)bp->bio_disk->d_drv1;
+	softc = part->sc;
+	periph = softc->periph;
+	cam_periph_lock(periph);
+	ret = xpt_getattr(bp->bio_data, bp->bio_length, bp->bio_attribute,
+	    periph->path);
+	cam_periph_unlock(periph);
+	if (ret == 0)
+		bp->bio_completed = bp->bio_length;
+	return (ret);
+}
+
+static cam_status
+sddaregister(struct cam_periph *periph, void *arg)
+{
+	struct sdda_softc *softc;
+	struct ccb_getdev *cgd;
+	union ccb *request_ccb;	/* CCB representing the probe request */
+
+        CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddaregister\n"));
+	cgd = (struct ccb_getdev *)arg;
+	if (cgd == NULL) {
+		printf("sddaregister: no getdev CCB, can't register device\n");
+		return (CAM_REQ_CMP_ERR);
+	}
+
+	softc = (struct sdda_softc *)malloc(sizeof(*softc), M_DEVBUF,
+	    M_NOWAIT|M_ZERO);
+
+	if (softc == NULL) {
+		printf("sddaregister: Unable to probe new device. "
+		    "Unable to allocate softc\n");
+		return (CAM_REQ_CMP_ERR);
+	}
+
+	softc->state = SDDA_STATE_INIT;
+	softc->mmcdata =
+		(struct mmc_data *)malloc(sizeof(struct mmc_data), M_DEVBUF, M_NOWAIT|M_ZERO);
+	periph->softc = softc;
+	softc->periph = periph;
+
+	request_ccb = (union ccb*) arg;
+	xpt_schedule(periph, CAM_PRIORITY_XPT);
+	TASK_INIT(&softc->start_init_task, 0, sdda_start_init_task, periph);
+	taskqueue_enqueue(taskqueue_thread, &softc->start_init_task);
+
+	return (CAM_REQ_CMP);
+}
+
+static int
+mmc_exec_app_cmd(struct cam_periph *periph, union ccb *ccb,
+	struct mmc_command *cmd) {
+	int err;
+
+	/* Send APP_CMD first */
+	memset(&ccb->mmcio.cmd, 0, sizeof(struct mmc_command));
+	memset(&ccb->mmcio.stop, 0, sizeof(struct mmc_command));
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_NONE,
+		       /*mmc_opcode*/ MMC_APP_CMD,
+		       /*mmc_arg*/ get_rca(periph) << 16,
+		       /*mmc_flags*/ MMC_RSP_R1 | MMC_CMD_AC,
+		       /*mmc_data*/ NULL,
+		       /*timeout*/ 0);
+
+	err = cam_periph_runccb(ccb, sddaerror, CAM_FLAG_NONE, /*sense_flags*/0, NULL);
+	if (err != 0)
+		return err;
+	if (!(ccb->mmcio.cmd.resp[0] & R1_APP_CMD))
+		return MMC_ERR_FAILED;
+
+	/* Now exec actual command */
+	int flags = 0;
+	if (cmd->data != NULL) {
+		ccb->mmcio.cmd.data = cmd->data;
+		if (cmd->data->flags & MMC_DATA_READ)
+			flags |= CAM_DIR_IN;
+		if (cmd->data->flags & MMC_DATA_WRITE)
+			flags |= CAM_DIR_OUT;
+	} else flags = CAM_DIR_NONE;
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ flags,
+		       /*mmc_opcode*/ cmd->opcode,
+		       /*mmc_arg*/ cmd->arg,
+		       /*mmc_flags*/ cmd->flags,
+		       /*mmc_data*/ cmd->data,
+		       /*timeout*/ 0);
+
+	err = cam_periph_runccb(ccb, sddaerror, CAM_FLAG_NONE, /*sense_flags*/0, NULL);
+	memcpy(cmd->resp, ccb->mmcio.cmd.resp, sizeof(cmd->resp));
+	cmd->error = ccb->mmcio.cmd.error;
+	if (err != 0)
+		return err;
+	return 0;
+}
+
+static int
+mmc_app_get_scr(struct cam_periph *periph, union ccb *ccb, uint32_t *rawscr) {
+	int err;
+	struct mmc_command cmd;
+	struct mmc_data d;
+
+	memset(&cmd, 0, sizeof(cmd));
+	memset(&d, 0, sizeof(d));
+
+	memset(rawscr, 0, 8);
+	cmd.opcode = ACMD_SEND_SCR;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+	cmd.arg = 0;
+
+	d.data = rawscr;
+	d.len = 8;
+	d.flags = MMC_DATA_READ;
+	cmd.data = &d;
+
+	err = mmc_exec_app_cmd(periph, ccb, &cmd);
+	rawscr[0] = be32toh(rawscr[0]);
+	rawscr[1] = be32toh(rawscr[1]);
+	return (err);
+}
+
+static int
+mmc_send_ext_csd(struct cam_periph *periph, union ccb *ccb,
+		 uint8_t *rawextcsd, size_t buf_len) {
+	int err;
+	struct mmc_data d;
+
+	KASSERT(buf_len == 512, ("Buffer for ext csd must be 512 bytes"));
+	d.data = rawextcsd;
+	d.len = buf_len;
+	d.flags = MMC_DATA_READ;
+	memset(d.data, 0, d.len);
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_IN,
+		       /*mmc_opcode*/ MMC_SEND_EXT_CSD,
+		       /*mmc_arg*/ 0,
+		       /*mmc_flags*/ MMC_RSP_R1 | MMC_CMD_ADTC,
+		       /*mmc_data*/ &d,
+		       /*timeout*/ 0);
+
+	err = cam_periph_runccb(ccb, sddaerror, CAM_FLAG_NONE, /*sense_flags*/0, NULL);
+	if (err != 0)
+		return (err);
+	return (MMC_ERR_NONE);
+}
+
+static void
+mmc_app_decode_scr(uint32_t *raw_scr, struct mmc_scr *scr)
+{
+	unsigned int scr_struct;
+
+	memset(scr, 0, sizeof(*scr));
+
+	scr_struct = mmc_get_bits(raw_scr, 64, 60, 4);
+	if (scr_struct != 0) {
+		printf("Unrecognised SCR structure version %d\n",
+		    scr_struct);
+		return;
+	}
+	scr->sda_vsn = mmc_get_bits(raw_scr, 64, 56, 4);
+	scr->bus_widths = mmc_get_bits(raw_scr, 64, 48, 4);
+}
+
+static inline void
+mmc_switch_fill_mmcio(union ccb *ccb,
+    uint8_t set, uint8_t index, uint8_t value, u_int timeout)
+{
+	int arg = (MMC_SWITCH_FUNC_WR << 24) |
+	    (index << 16) |
+	    (value << 8) |
+	    set;
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_NONE,
+		       /*mmc_opcode*/ MMC_SWITCH_FUNC,
+		       /*mmc_arg*/ arg,
+		       /*mmc_flags*/ MMC_RSP_R1B | MMC_CMD_AC,
+		       /*mmc_data*/ NULL,
+		       /*timeout*/ timeout);
+}
+
+static int
+mmc_select_card(struct cam_periph *periph, union ccb *ccb, uint32_t rca)
+{
+	int flags;
+
+	flags = (rca ? MMC_RSP_R1B : MMC_RSP_NONE) | MMC_CMD_AC;
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_IN,
+		       /*mmc_opcode*/ MMC_SELECT_CARD,
+		       /*mmc_arg*/ rca << 16,
+		       /*mmc_flags*/ flags,
+		       /*mmc_data*/ NULL,
+		       /*timeout*/ 0);
+
+	cam_periph_runccb(ccb, sddaerror, CAM_FLAG_NONE, /*sense_flags*/0, NULL);
+
+	if (((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP)) {
+		if (ccb->mmcio.cmd.error != 0) {
+			CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_PERIPH,
+				  ("%s: MMC_SELECT command failed", __func__));
+			return EIO;
+		}
+		return 0; /* Normal return */
+	} else {
+		CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_PERIPH,
+			  ("%s: CAM request failed\n", __func__));
+		return EIO;
+	}
+}
+
+static int
+mmc_switch(struct cam_periph *periph, union ccb *ccb,
+    uint8_t set, uint8_t index, uint8_t value, u_int timeout)
+{
+
+	mmc_switch_fill_mmcio(ccb, set, index, value, timeout);
+	cam_periph_runccb(ccb, sddaerror, CAM_FLAG_NONE, /*sense_flags*/0, NULL);
+
+	if (((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP)) {
+		if (ccb->mmcio.cmd.error != 0) {
+			CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_PERIPH,
+				  ("%s: MMC command failed", __func__));
+			return (EIO);
+		}
+		return (0); /* Normal return */
+	} else {
+		CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_PERIPH,
+			  ("%s: CAM request failed\n", __func__));
+		return (EIO);
+	}
+
+}
+
+static uint32_t
+mmc_get_spec_vers(struct cam_periph *periph) {
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+
+	return (softc->csd.spec_vers);
+}
+
+static uint64_t
+mmc_get_media_size(struct cam_periph *periph) {
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+
+	return (softc->mediasize);
+}
+
+static uint32_t
+mmc_get_cmd6_timeout(struct cam_periph *periph)
+{
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+
+	if (mmc_get_spec_vers(periph) >= 6)
+		return (softc->raw_ext_csd[EXT_CSD_GEN_CMD6_TIME] * 10);
+	return (500 * 1000);
+}
+
+static int
+mmc_sd_switch(struct cam_periph *periph, union ccb *ccb,
+	      uint8_t mode, uint8_t grp, uint8_t value,
+	      uint8_t *res) {
+
+	struct mmc_data mmc_d;
+	uint32_t arg;
+
+	memset(res, 0, 64);
+	mmc_d.len = 64;
+	mmc_d.data = res;
+	mmc_d.flags = MMC_DATA_READ;
+
+	arg = mode << 31;			/* 0 - check, 1 - set */
+	arg |= 0x00FFFFFF;
+	arg &= ~(0xF << (grp * 4));
+	arg |= value << (grp * 4);
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_IN,
+		       /*mmc_opcode*/ SD_SWITCH_FUNC,
+		       /*mmc_arg*/ arg,
+		       /*mmc_flags*/ MMC_RSP_R1 | MMC_CMD_ADTC,
+		       /*mmc_data*/ &mmc_d,
+		       /*timeout*/ 0);
+
+	cam_periph_runccb(ccb, sddaerror, CAM_FLAG_NONE, /*sense_flags*/0, NULL);
+
+	if (((ccb->ccb_h.status & CAM_STATUS_MASK) == CAM_REQ_CMP)) {
+		if (ccb->mmcio.cmd.error != 0) {
+			CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_PERIPH,
+				  ("%s: MMC command failed", __func__));
+			return EIO;
+		}
+		return 0; /* Normal return */
+	} else {
+		CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_PERIPH,
+			  ("%s: CAM request failed\n", __func__));
+		return EIO;
+	}
+}
+
+static int
+mmc_set_timing(struct cam_periph *periph,
+	       union ccb *ccb,
+	       enum mmc_bus_timing timing)
+{
+	u_char switch_res[64];
+	int err;
+	uint8_t	value;
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+	struct mmc_params *mmcp = &periph->path->device->mmc_ident_data;
+
+	CAM_DEBUG(ccb->ccb_h.path, CAM_DEBUG_TRACE,
+		  ("mmc_set_timing(timing=%d)", timing));
+	switch (timing) {
+	case bus_timing_normal:
+		value = 0;
+		break;
+	case bus_timing_hs:
+		value = 1;
+		break;
+	default:
+		return (MMC_ERR_INVALID);
+	}
+	if (mmcp->card_features & CARD_FEATURE_MMC) {
+		err = mmc_switch(periph, ccb, EXT_CSD_CMD_SET_NORMAL,
+		    EXT_CSD_HS_TIMING, value, softc->cmd6_time);
+	} else {
+		err = mmc_sd_switch(periph, ccb, SD_SWITCH_MODE_SET, SD_SWITCH_GROUP1, value, switch_res);
+	}
+
+	/* Set high-speed timing on the host */
+	struct ccb_trans_settings_mmc *cts;
+	cts = &ccb->cts.proto_specific.mmc;
+	ccb->ccb_h.func_code = XPT_SET_TRAN_SETTINGS;
+	ccb->ccb_h.flags = CAM_DIR_NONE;
+	ccb->ccb_h.retry_count = 0;
+	ccb->ccb_h.timeout = 100;
+	ccb->ccb_h.cbfcnp = NULL;
+	cts->ios.timing = timing;
+	cts->ios_valid = MMC_BT;
+	xpt_action(ccb);
+
+	return (err);
+}
+
+static void
+sdda_start_init_task(void *context, int pending) {
+	union ccb *new_ccb;
+	struct cam_periph *periph;
+
+	periph = (struct cam_periph *)context;
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sdda_start_init_task\n"));
+	new_ccb = xpt_alloc_ccb();
+	xpt_setup_ccb(&new_ccb->ccb_h, periph->path,
+		      CAM_PRIORITY_NONE);
+
+	cam_periph_lock(periph);
+	sdda_start_init(context, new_ccb);
+	cam_periph_unlock(periph);
+	xpt_free_ccb(new_ccb);
+}
+
+static void
+sdda_set_bus_width(struct cam_periph *periph, union ccb *ccb, int width) {
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+	struct mmc_params *mmcp = &periph->path->device->mmc_ident_data;
+	int err;
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sdda_set_bus_width\n"));
+
+	/* First set for the card, then for the host */
+	if (mmcp->card_features & CARD_FEATURE_MMC) {
+		uint8_t	value;
+		switch (width) {
+		case bus_width_1:
+			value = EXT_CSD_BUS_WIDTH_1;
+			break;
+		case bus_width_4:
+			value = EXT_CSD_BUS_WIDTH_4;
+			break;
+		case bus_width_8:
+			value = EXT_CSD_BUS_WIDTH_8;
+			break;
+		default:
+			panic("Invalid bus width %d", width);
+		}
+		err = mmc_switch(periph, ccb, EXT_CSD_CMD_SET_NORMAL,
+		    EXT_CSD_BUS_WIDTH, value, softc->cmd6_time);
+	} else {
+		/* For SD cards we send ACMD6 with the required bus width in arg */
+		struct mmc_command cmd;
+		memset(&cmd, 0, sizeof(struct mmc_command));
+		cmd.opcode = ACMD_SET_BUS_WIDTH;
+		cmd.arg = width;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		err = mmc_exec_app_cmd(periph, ccb, &cmd);
+	}
+
+	if (err != MMC_ERR_NONE) {
+		CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH, ("Error %d when setting bus width on the card\n", err));
+		return;
+	}
+	/* Now card is done, set the host to the same width */
+	struct ccb_trans_settings_mmc *cts;
+	cts = &ccb->cts.proto_specific.mmc;
+	ccb->ccb_h.func_code = XPT_SET_TRAN_SETTINGS;
+	ccb->ccb_h.flags = CAM_DIR_NONE;
+	ccb->ccb_h.retry_count = 0;
+	ccb->ccb_h.timeout = 100;
+	ccb->ccb_h.cbfcnp = NULL;
+	cts->ios.bus_width = width;
+	cts->ios_valid = MMC_BW;
+	xpt_action(ccb);
+}
+
+static inline const char
+*part_type(u_int type)
+{
+
+	switch (type) {
+	case EXT_CSD_PART_CONFIG_ACC_RPMB:
+		return ("RPMB");
+	case EXT_CSD_PART_CONFIG_ACC_DEFAULT:
+		return ("default");
+	case EXT_CSD_PART_CONFIG_ACC_BOOT0:
+		return ("boot0");
+	case EXT_CSD_PART_CONFIG_ACC_BOOT1:
+		return ("boot1");
+	case EXT_CSD_PART_CONFIG_ACC_GP0:
+	case EXT_CSD_PART_CONFIG_ACC_GP1:
+	case EXT_CSD_PART_CONFIG_ACC_GP2:
+	case EXT_CSD_PART_CONFIG_ACC_GP3:
+		return ("general purpose");
+	default:
+		return ("(unknown type)");
+	}
+}
+
+static inline const char
+*bus_width_str(enum mmc_bus_width w)
+{
+
+	switch (w) {
+	case bus_width_1:
+		return ("1-bit");
+	case bus_width_4:
+		return ("4-bit");
+	case bus_width_8:
+		return ("8-bit");
+	}
+}
+
+static uint32_t
+sdda_get_host_caps(struct cam_periph *periph, union ccb *ccb)
+{
+	struct ccb_trans_settings_mmc *cts;
+
+	cts = &ccb->cts.proto_specific.mmc;
+
+	ccb->ccb_h.func_code = XPT_GET_TRAN_SETTINGS;
+	ccb->ccb_h.flags = CAM_DIR_NONE;
+	ccb->ccb_h.retry_count = 0;
+	ccb->ccb_h.timeout = 100;
+	ccb->ccb_h.cbfcnp = NULL;
+	xpt_action(ccb);
+
+	if (ccb->ccb_h.status != CAM_REQ_CMP)
+		panic("Cannot get host caps");
+	return (cts->host_caps);
+}
+
+static void
+sdda_start_init(void *context, union ccb *start_ccb)
+{
+	struct cam_periph *periph = (struct cam_periph *)context;
+	struct ccb_trans_settings_mmc *cts;
+	uint32_t host_caps;
+	uint32_t sec_count;
+	int err;
+	int host_f_max;
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sdda_start_init\n"));
+	/* periph was held for us when this task was enqueued */
+	if ((periph->flags & CAM_PERIPH_INVALID) != 0) {
+		cam_periph_release(periph);
+		return;
+	}
+
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+	//struct ccb_mmcio *mmcio = &start_ccb->mmcio;
+	struct mmc_params *mmcp = &periph->path->device->mmc_ident_data;
+	struct cam_ed *device = periph->path->device;
+
+	if (mmcp->card_features & CARD_FEATURE_MMC) {
+		mmc_decode_csd_mmc(mmcp->card_csd, &softc->csd);
+		mmc_decode_cid_mmc(mmcp->card_cid, &softc->cid);
+		if (mmc_get_spec_vers(periph) >= 4) {
+			err = mmc_send_ext_csd(periph, start_ccb,
+					       (uint8_t *)&softc->raw_ext_csd,
+					       sizeof(softc->raw_ext_csd));
+			if (err != 0) {
+				CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+				    ("Cannot read EXT_CSD, err %d", err));
+				return;
+			}
+		}
+	} else {
+		mmc_decode_csd_sd(mmcp->card_csd, &softc->csd);
+		mmc_decode_cid_sd(mmcp->card_cid, &softc->cid);
+	}
+
+	softc->sector_count = softc->csd.capacity / 512;
+	softc->mediasize = softc->csd.capacity;
+	softc->cmd6_time = mmc_get_cmd6_timeout(periph);
+
+	/* MMC >= 4.x have EXT_CSD that has its own opinion about capacity */
+	if (mmc_get_spec_vers(periph) >= 4) {
+		sec_count = softc->raw_ext_csd[EXT_CSD_SEC_CNT] +
+		    (softc->raw_ext_csd[EXT_CSD_SEC_CNT + 1] << 8) +
+		    (softc->raw_ext_csd[EXT_CSD_SEC_CNT + 2] << 16) +
+		    (softc->raw_ext_csd[EXT_CSD_SEC_CNT + 3] << 24);
+		if (sec_count != 0) {
+			softc->sector_count = sec_count;
+			softc->mediasize = softc->sector_count * 512;
+			/* FIXME: there should be a better name for this option...*/
+			mmcp->card_features |= CARD_FEATURE_SDHC;
+		}
+
+	}
+	CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+	    ("Capacity: %"PRIu64", sectors: %"PRIu64"\n",
+		softc->mediasize,
+		softc->sector_count));
+	mmc_format_card_id_string(softc, mmcp);
+
+	/* Update info for CAM */
+	device->serial_num_len = strlen(softc->card_sn_string);
+	device->serial_num = (u_int8_t *)malloc((device->serial_num_len + 1),
+	    M_CAMXPT, M_NOWAIT);
+	strlcpy(device->serial_num, softc->card_sn_string, device->serial_num_len);
+
+	device->device_id_len = strlen(softc->card_id_string);
+	device->device_id = (u_int8_t *)malloc((device->device_id_len + 1),
+	    M_CAMXPT, M_NOWAIT);
+	strlcpy(device->device_id, softc->card_id_string, device->device_id_len);
+
+	strlcpy(mmcp->model, softc->card_id_string, sizeof(mmcp->model));
+
+	/* Set the clock frequency that the card can handle */
+	cts = &start_ccb->cts.proto_specific.mmc;
+
+	/* First, get the host's max freq */
+	start_ccb->ccb_h.func_code = XPT_GET_TRAN_SETTINGS;
+	start_ccb->ccb_h.flags = CAM_DIR_NONE;
+	start_ccb->ccb_h.retry_count = 0;
+	start_ccb->ccb_h.timeout = 100;
+	start_ccb->ccb_h.cbfcnp = NULL;
+	xpt_action(start_ccb);
+
+	if (start_ccb->ccb_h.status != CAM_REQ_CMP)
+		panic("Cannot get max host freq");
+	host_f_max = cts->host_f_max;
+	host_caps = cts->host_caps;
+	if (cts->ios.bus_width != bus_width_1)
+		panic("Bus width in ios is not 1-bit");
+
+	/* Now check if the card supports High-speed */
+	softc->card_f_max = softc->csd.tran_speed;
+
+	if (host_caps & MMC_CAP_HSPEED) {
+		/* Find out if the card supports High speed timing */
+		if (mmcp->card_features & CARD_FEATURE_SD20) {
+			/* Get and decode SCR */
+			uint32_t rawscr[2];
+			uint8_t res[64];
+			if (mmc_app_get_scr(periph, start_ccb, rawscr)) {
+				CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH, ("Cannot get SCR\n"));
+				goto finish_hs_tests;
+			}
+			mmc_app_decode_scr(rawscr, &softc->scr);
+
+			if ((softc->scr.sda_vsn >= 1) && (softc->csd.ccc & (1<<10))) {
+				mmc_sd_switch(periph, start_ccb, SD_SWITCH_MODE_CHECK,
+					      SD_SWITCH_GROUP1, SD_SWITCH_NOCHANGE, res);
+				if (res[13] & 2) {
+					CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH, ("Card supports HS\n"));
+					softc->card_f_max = SD_HS_MAX;
+				}
+
+				/*
+				 * We deselect then reselect the card here.  Some cards
+				 * become unselected and timeout with the above two
+				 * commands, although the state tables / diagrams in the
+				 * standard suggest they go back to the transfer state.
+				 * Other cards don't become deselected, and if we
+				 * attempt to blindly re-select them, we get timeout
+				 * errors from some controllers.  So we deselect then
+				 * reselect to handle all situations.
+				 */
+				mmc_select_card(periph, start_ccb, 0);
+				mmc_select_card(periph, start_ccb, get_rca(periph));
+			} else {
+				CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH, ("Not trying the switch\n"));
+				goto finish_hs_tests;
+			}
+		}
+
+		if (mmcp->card_features & CARD_FEATURE_MMC && mmc_get_spec_vers(periph) >= 4) {
+			if (softc->raw_ext_csd[EXT_CSD_CARD_TYPE]
+			    & EXT_CSD_CARD_TYPE_HS_52)
+				softc->card_f_max = MMC_TYPE_HS_52_MAX;
+			else if (softc->raw_ext_csd[EXT_CSD_CARD_TYPE]
+				 & EXT_CSD_CARD_TYPE_HS_26)
+				softc->card_f_max = MMC_TYPE_HS_26_MAX;
+		}
+	}
+	int f_max;
+finish_hs_tests:
+	f_max = min(host_f_max, softc->card_f_max);
+	CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH, ("Set SD freq to %d MHz (min out of host f=%d MHz and card f=%d MHz)\n", f_max  / 1000000, host_f_max / 1000000, softc->card_f_max / 1000000));
+
+	/* Enable high-speed timing on the card */
+	if (f_max > 25000000) {
+		err = mmc_set_timing(periph, start_ccb, bus_timing_hs);
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("Cannot switch card to high-speed mode"));
+			f_max = 25000000;
+		}
+	}
+	/* Set frequency on the controller */
+	start_ccb->ccb_h.func_code = XPT_SET_TRAN_SETTINGS;
+	start_ccb->ccb_h.flags = CAM_DIR_NONE;
+	start_ccb->ccb_h.retry_count = 0;
+	start_ccb->ccb_h.timeout = 100;
+	start_ccb->ccb_h.cbfcnp = NULL;
+	cts->ios.clock = f_max;
+	cts->ios_valid = MMC_CLK;
+	xpt_action(start_ccb);
+
+	/* Set bus width */
+	enum mmc_bus_width desired_bus_width = bus_width_1;
+	enum mmc_bus_width max_host_bus_width =
+		(host_caps & MMC_CAP_8_BIT_DATA ? bus_width_8 :
+		 host_caps & MMC_CAP_4_BIT_DATA ? bus_width_4 : bus_width_1);
+	enum mmc_bus_width max_card_bus_width = bus_width_1;
+	if (mmcp->card_features & CARD_FEATURE_SD20 &&
+	    softc->scr.bus_widths & SD_SCR_BUS_WIDTH_4)
+		max_card_bus_width = bus_width_4;
+	/*
+	 * Unlike SD, MMC cards don't have any information about supported bus width...
+	 * So we need to perform read/write test to find out the width.
+	 */
+	/* TODO: figure out bus width for MMC; use 8-bit for now (to test on BBB) */
+	if (mmcp->card_features & CARD_FEATURE_MMC)
+		max_card_bus_width = bus_width_8;
+
+	desired_bus_width = min(max_host_bus_width, max_card_bus_width);
+	CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+		  ("Set bus width to %s (min of host %s and card %s)\n",
+		   bus_width_str(desired_bus_width),
+		   bus_width_str(max_host_bus_width),
+		   bus_width_str(max_card_bus_width)));
+	sdda_set_bus_width(periph, start_ccb, desired_bus_width);
+
+	softc->state = SDDA_STATE_NORMAL;
+
+	/* MMC partitions support */
+	if (mmcp->card_features & CARD_FEATURE_MMC && mmc_get_spec_vers(periph) >= 4) {
+		sdda_process_mmc_partitions(periph, start_ccb);
+	} else if (mmcp->card_features & CARD_FEATURE_SD20) {
+		/* For SD[HC] cards, just add one partition that is the whole card */
+		sdda_add_part(periph, 0, "sdda",
+		    periph->unit_number,
+		    mmc_get_media_size(periph),
+		    sdda_get_read_only(periph, start_ccb));
+		softc->part_curr = 0;
+	}
+
+	xpt_announce_periph(periph, softc->card_id_string);
+	/*
+	 * Add async callbacks for bus reset and bus device reset calls.
+	 * I don't bother checking if this fails as, in most cases,
+	 * the system will function just fine without them and the only
+	 * alternative would be to not attach the device on failure.
+	 */
+	xpt_register_async(AC_LOST_DEVICE | AC_GETDEV_CHANGED |
+	    AC_ADVINFO_CHANGED, sddaasync, periph, periph->path);
+}
+
+static void
+sdda_add_part(struct cam_periph *periph, u_int type, const char *name,
+    u_int cnt, off_t media_size, bool ro)
+{
+	struct sdda_softc *sc = (struct sdda_softc *)periph->softc;
+	struct sdda_part *part;
+	struct ccb_pathinq cpi;
+	u_int maxio;
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+	    ("Partition type '%s', size %ju %s\n",
+	    part_type(type),
+	    media_size,
+	    ro ? "(read-only)" : ""));
+
+	part = sc->part[type] = malloc(sizeof(*part), M_DEVBUF,
+	    M_WAITOK | M_ZERO);
+
+	part->cnt = cnt;
+	part->type = type;
+	part->ro = ro;
+	part->sc = sc;
+	snprintf(part->name, sizeof(part->name), name, periph->unit_number);
+
+	/*
+	 * Due to the nature of RPMB partition it doesn't make much sense
+	 * to add it as a disk. It would be more appropriate to create a
+	 * userland tool to operate on the partition or leverage the existing
+	 * tools from sysutils/mmc-utils.
+	 */
+	if (type == EXT_CSD_PART_CONFIG_ACC_RPMB) {
+		/* TODO: Create device, assign IOCTL handler */
+		CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+		    ("Don't know what to do with RPMB partitions yet\n"));
+		return;
+	}
+
+	bioq_init(&part->bio_queue);
+
+	bzero(&cpi, sizeof(cpi));
+	xpt_setup_ccb(&cpi.ccb_h, periph->path, CAM_PRIORITY_NONE);
+	cpi.ccb_h.func_code = XPT_PATH_INQ;
+	xpt_action((union ccb *)&cpi);
+
+	/*
+	 * Register this media as a disk
+	 */
+	(void)cam_periph_hold(periph, PRIBIO);
+	cam_periph_unlock(periph);
+
+	part->disk = disk_alloc();
+	part->disk->d_rotation_rate = DISK_RR_NON_ROTATING;
+	part->disk->d_devstat = devstat_new_entry(part->name,
+	    cnt, 512,
+	    DEVSTAT_ALL_SUPPORTED,
+	    DEVSTAT_TYPE_DIRECT | XPORT_DEVSTAT_TYPE(cpi.transport),
+	    DEVSTAT_PRIORITY_DISK);
+
+	part->disk->d_open = sddaopen;
+	part->disk->d_close = sddaclose;
+	part->disk->d_strategy = sddastrategy;
+	part->disk->d_getattr = sddagetattr;
+//	sc->disk->d_dump = sddadump;
+	part->disk->d_gone = sddadiskgonecb;
+	part->disk->d_name = part->name;
+	part->disk->d_drv1 = part;
+	maxio = cpi.maxio;		/* Honor max I/O size of SIM */
+	if (maxio == 0)
+		maxio = DFLTPHYS;	/* traditional default */
+	else if (maxio > MAXPHYS)
+		maxio = MAXPHYS;	/* for safety */
+	part->disk->d_maxsize = maxio;
+	part->disk->d_unit = cnt;
+	part->disk->d_flags = 0;
+	strlcpy(part->disk->d_descr, sc->card_id_string,
+	    MIN(sizeof(part->disk->d_descr), sizeof(sc->card_id_string)));
+	strlcpy(part->disk->d_ident, sc->card_sn_string,
+	    MIN(sizeof(part->disk->d_ident), sizeof(sc->card_sn_string)));
+	part->disk->d_hba_vendor = cpi.hba_vendor;
+	part->disk->d_hba_device = cpi.hba_device;
+	part->disk->d_hba_subvendor = cpi.hba_subvendor;
+	part->disk->d_hba_subdevice = cpi.hba_subdevice;
+
+	part->disk->d_sectorsize = mmc_get_sector_size(periph);
+	part->disk->d_mediasize = media_size;
+	part->disk->d_stripesize = 0;
+	part->disk->d_fwsectors = 0;
+	part->disk->d_fwheads = 0;
+
+	/*
+	 * Acquire a reference to the periph before we register with GEOM.
+	 * We'll release this reference once GEOM calls us back (via
+	 * sddadiskgonecb()) telling us that our provider has been freed.
+	 */
+	if (cam_periph_acquire(periph) != CAM_REQ_CMP) {
+		xpt_print(periph->path, "%s: lost periph during "
+		    "registration!\n", __func__);
+		cam_periph_lock(periph);
+		return;
+	}
+	disk_create(part->disk, DISK_VERSION);
+	cam_periph_lock(periph);
+	cam_periph_unhold(periph);
+}
+
+/*
+ * For MMC cards, process EXT_CSD and add partitions that are supported by
+ * this device.
+ */
+static void
+sdda_process_mmc_partitions(struct cam_periph *periph, union ccb *ccb)
+{
+	struct sdda_softc *sc = (struct sdda_softc *)periph->softc;
+	struct mmc_params *mmcp = &periph->path->device->mmc_ident_data;
+	off_t erase_size, sector_size, size, wp_size;
+	int i;
+	const uint8_t *ext_csd;
+	uint8_t rev;
+	bool comp, ro;
+
+	ext_csd = sc->raw_ext_csd;
+
+	/*
+	 * Enhanced user data area and general purpose partitions are only
+	 * supported in revision 1.4 (EXT_CSD_REV == 4) and later, the RPMB
+	 * partition in revision 1.5 (MMC v4.41, EXT_CSD_REV == 5) and later.
+	 */
+	rev = ext_csd[EXT_CSD_REV];
+
+	/*
+	 * Ignore user-creatable enhanced user data area and general purpose
+	 * partitions partitions as long as partitioning hasn't been finished.
+	 */
+	comp = (ext_csd[EXT_CSD_PART_SET] & EXT_CSD_PART_SET_COMPLETED) != 0;
+
+	/*
+	 * Add enanced user data area slice, unless it spans the entirety of
+	 * the user data area.  The enhanced area is of a multiple of high
+	 * capacity write protect groups ((ERASE_GRP_SIZE + HC_WP_GRP_SIZE) *
+	 * 512 KB) and its offset given in either sectors or bytes, depending
+	 * on whether it's a high capacity device or not.
+	 * NB: The slicer and its slices need to be registered before adding
+	 *     the disk for the corresponding user data area as re-tasting is
+	 *     racy.
+	 */
+	sector_size = mmc_get_sector_size(periph);
+	size = ext_csd[EXT_CSD_ENH_SIZE_MULT] +
+		(ext_csd[EXT_CSD_ENH_SIZE_MULT + 1] << 8) +
+		(ext_csd[EXT_CSD_ENH_SIZE_MULT + 2] << 16);
+	if (rev >= 4 && comp == TRUE && size > 0 &&
+	    (ext_csd[EXT_CSD_PART_SUPPORT] &
+		EXT_CSD_PART_SUPPORT_ENH_ATTR_EN) != 0 &&
+	    (ext_csd[EXT_CSD_PART_ATTR] & (EXT_CSD_PART_ATTR_ENH_USR)) != 0) {
+		erase_size = ext_csd[EXT_CSD_ERASE_GRP_SIZE] * 1024 *
+			MMC_SECTOR_SIZE;
+		wp_size = ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+		size *= erase_size * wp_size;
+		if (size != mmc_get_media_size(periph) * sector_size) {
+			sc->enh_size = size;
+			sc->enh_base = (ext_csd[EXT_CSD_ENH_START_ADDR] +
+			    (ext_csd[EXT_CSD_ENH_START_ADDR + 1] << 8) +
+			    (ext_csd[EXT_CSD_ENH_START_ADDR + 2] << 16) +
+			    (ext_csd[EXT_CSD_ENH_START_ADDR + 3] << 24)) *
+				((mmcp->card_features & CARD_FEATURE_SDHC) ? 1: MMC_SECTOR_SIZE);
+		} else
+			CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+			    ("enhanced user data area spans entire device"));
+	}
+
+	/*
+	 * Add default partition.  This may be the only one or the user
+	 * data area in case partitions are supported.
+	 */
+	ro = sdda_get_read_only(periph, ccb);
+	sdda_add_part(periph, EXT_CSD_PART_CONFIG_ACC_DEFAULT, "sdda",
+	    periph->unit_number, mmc_get_media_size(periph), ro);
+	sc->part_curr = EXT_CSD_PART_CONFIG_ACC_DEFAULT;
+
+	if (mmc_get_spec_vers(periph) < 3)
+		return;
+
+	/* Belatedly announce enhanced user data slice. */
+	if (sc->enh_size != 0) {
+		CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+		    ("enhanced user data area off 0x%jx size %ju bytes\n",
+			sc->enh_base, sc->enh_size));
+	}
+
+	/*
+	 * Determine partition switch timeout (provided in units of 10 ms)
+	 * and ensure it's at least 300 ms as some eMMC chips lie.
+	 */
+	sc->part_time = max(ext_csd[EXT_CSD_PART_SWITCH_TO] * 10 * 1000,
+	    300 * 1000);
+
+	/* Add boot partitions, which are of a fixed multiple of 128 KB. */
+	size = ext_csd[EXT_CSD_BOOT_SIZE_MULT] * MMC_BOOT_RPMB_BLOCK_SIZE;
+	if (size > 0 && (sdda_get_host_caps(periph, ccb) & MMC_CAP_BOOT_NOACC) == 0) {
+		sdda_add_part(periph, EXT_CSD_PART_CONFIG_ACC_BOOT0,
+		    SDDA_FMT_BOOT, 0, size,
+		    ro | ((ext_csd[EXT_CSD_BOOT_WP_STATUS] &
+		    EXT_CSD_BOOT_WP_STATUS_BOOT0_MASK) != 0));
+		sdda_add_part(periph, EXT_CSD_PART_CONFIG_ACC_BOOT1,
+		    SDDA_FMT_BOOT, 1, size,
+		    ro | ((ext_csd[EXT_CSD_BOOT_WP_STATUS] &
+		    EXT_CSD_BOOT_WP_STATUS_BOOT1_MASK) != 0));
+	}
+
+	/* Add RPMB partition, which also is of a fixed multiple of 128 KB. */
+	size = ext_csd[EXT_CSD_RPMB_MULT] * MMC_BOOT_RPMB_BLOCK_SIZE;
+	if (rev >= 5 && size > 0)
+		sdda_add_part(periph, EXT_CSD_PART_CONFIG_ACC_RPMB,
+		    SDDA_FMT_RPMB, 0, size, ro);
+
+	if (rev <= 3 || comp == FALSE)
+		return;
+
+	/*
+	 * Add general purpose partitions, which are of a multiple of high
+	 * capacity write protect groups, too.
+	 */
+	if ((ext_csd[EXT_CSD_PART_SUPPORT] & EXT_CSD_PART_SUPPORT_EN) != 0) {
+		erase_size = ext_csd[EXT_CSD_ERASE_GRP_SIZE] * 1024 *
+			MMC_SECTOR_SIZE;
+		wp_size = ext_csd[EXT_CSD_HC_WP_GRP_SIZE];
+		for (i = 0; i < MMC_PART_GP_MAX; i++) {
+			size = ext_csd[EXT_CSD_GP_SIZE_MULT + i * 3] +
+				(ext_csd[EXT_CSD_GP_SIZE_MULT + i * 3 + 1] << 8) +
+				(ext_csd[EXT_CSD_GP_SIZE_MULT + i * 3 + 2] << 16);
+			if (size == 0)
+				continue;
+			sdda_add_part(periph, EXT_CSD_PART_CONFIG_ACC_GP0 + i,
+			    SDDA_FMT_GP, i, size * erase_size * wp_size, ro);
+		}
+	}
+}
+
+/*
+ * We cannot just call mmc_switch() since it will sleep, and we are in
+ * GEOM context and cannot sleep. Instead, create an MMCIO request to switch
+ * partitions and send it to h/w, and upon completion resume processing
+ * the I/O que This function cannot fail, instead check switch errors in sddadone().
+ */
+static void
+sdda_init_switch_part(struct cam_periph *periph, union ccb *start_ccb, u_int part) {
+	struct sdda_softc *sc = (struct sdda_softc *)periph->softc;
+	uint8_t value;
+
+	sc->part_requested = part;
+
+	value = (sc->raw_ext_csd[EXT_CSD_PART_CONFIG] &
+	    ~EXT_CSD_PART_CONFIG_ACC_MASK) | part;
+
+	mmc_switch_fill_mmcio(start_ccb, EXT_CSD_CMD_SET_NORMAL,
+	    EXT_CSD_PART_CONFIG, value, sc->part_time);
+	start_ccb->ccb_h.cbfcnp = sddadone;
+
+	sc->outstanding_cmds++;
+	cam_periph_unlock(periph);
+	xpt_action(start_ccb);
+	cam_periph_lock(periph);
+}
+
+/* Called with periph lock held! */
+static void
+sddastart(struct cam_periph *periph, union ccb *start_ccb)
+{
+	struct bio *bp;
+	struct sdda_softc *softc = (struct sdda_softc *)periph->softc;
+	struct sdda_part *part;
+	struct mmc_params *mmcp = &periph->path->device->mmc_ident_data;
+	int part_index;
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("sddastart\n"));
+
+	if (softc->state != SDDA_STATE_NORMAL) {
+		CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("device is not in SDDA_STATE_NORMAL yet\n"));
+		xpt_release_ccb(start_ccb);
+		return;
+	}
+
+	/* Find partition that has outstanding commands.  Prefer current partition. */
+	part = softc->part[softc->part_curr];
+	bp = bioq_first(&part->bio_queue);
+	if (bp == NULL) {
+		for (part_index = 0; part_index < MMC_PART_MAX; part_index++) {
+			if ((part = softc->part[part_index]) != NULL &&
+			    (bp = bioq_first(&softc->part[part_index]->bio_queue)) != NULL)
+				break;
+		}
+	}
+	if (bp == NULL) {
+		xpt_release_ccb(start_ccb);
+		return;
+	}
+	if (part_index != softc->part_curr) {
+		CAM_DEBUG(periph->path, CAM_DEBUG_PERIPH,
+		    ("Partition  %d -> %d\n", softc->part_curr, part_index));
+		/*
+		 * According to section "6.2.2 Command restrictions" of the eMMC
+		 * specification v5.1, CMD19/CMD21 aren't allowed to be used with
+		 * RPMB partitions.  So we pause re-tuning along with triggering
+		 * it up-front to decrease the likelihood of re-tuning becoming
+		 * necessary while accessing an RPMB partition.  Consequently, an
+		 * RPMB partition should immediately be switched away from again
+		 * after an access in order to allow for re-tuning to take place
+		 * anew.
+		 */
+		/* TODO: pause retune if switching to RPMB partition */
+		softc->state = SDDA_STATE_PART_SWITCH;
+		sdda_init_switch_part(periph, start_ccb, part_index);
+		return;
+	}
+
+	bioq_remove(&part->bio_queue, bp);
+
+	switch (bp->bio_cmd) {
+	case BIO_WRITE:
+		CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("BIO_WRITE\n"));
+		part->flags |= SDDA_FLAG_DIRTY;
+		/* FALLTHROUGH */
+	case BIO_READ:
+	{
+		struct ccb_mmcio *mmcio;
+		uint64_t blockno = bp->bio_pblkno;
+		uint16_t count = bp->bio_bcount / 512;
+		uint16_t opcode;
+
+		if (bp->bio_cmd == BIO_READ)
+			CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("BIO_READ\n"));
+		CAM_DEBUG(periph->path, CAM_DEBUG_TRACE,
+		    ("Block %"PRIu64" cnt %u\n", blockno, count));
+
+		/* Construct new MMC command */
+		if (bp->bio_cmd == BIO_READ) {
+			if (count > 1)
+				opcode = MMC_READ_MULTIPLE_BLOCK;
+			else
+				opcode = MMC_READ_SINGLE_BLOCK;
+		} else {
+			if (count > 1)
+				opcode = MMC_WRITE_MULTIPLE_BLOCK;
+			else
+				opcode = MMC_WRITE_BLOCK;
+		}
+
+		start_ccb->ccb_h.func_code = XPT_MMC_IO;
+		start_ccb->ccb_h.flags = (bp->bio_cmd == BIO_READ ? CAM_DIR_IN : CAM_DIR_OUT);
+		start_ccb->ccb_h.retry_count = 0;
+		start_ccb->ccb_h.timeout = 15 * 1000;
+		start_ccb->ccb_h.cbfcnp = sddadone;
+
+		mmcio = &start_ccb->mmcio;
+		mmcio->cmd.opcode = opcode;
+		mmcio->cmd.arg = blockno;
+		if (!(mmcp->card_features & CARD_FEATURE_SDHC))
+			mmcio->cmd.arg <<= 9;
+
+		mmcio->cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+		mmcio->cmd.data = softc->mmcdata;
+		mmcio->cmd.data->data = bp->bio_data;
+		mmcio->cmd.data->len = 512 * count;
+		mmcio->cmd.data->flags = (bp->bio_cmd == BIO_READ ? MMC_DATA_READ : MMC_DATA_WRITE);
+		/* Direct h/w to issue CMD12 upon completion */
+		if (count > 1) {
+			mmcio->cmd.data->flags |= MMC_DATA_MULTI;
+			mmcio->stop.opcode = MMC_STOP_TRANSMISSION;
+			mmcio->stop.flags = MMC_RSP_R1B | MMC_CMD_AC;
+			mmcio->stop.arg = 0;
+		}
+		break;
+	}
+	case BIO_FLUSH:
+		CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("BIO_FLUSH\n"));
+		sddaschedule(periph);
+		break;
+	case BIO_DELETE:
+		CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("BIO_DELETE\n"));
+		sddaschedule(periph);
+		break;
+	}
+	start_ccb->ccb_h.ccb_bp = bp;
+	softc->outstanding_cmds++;
+	softc->refcount++;
+	cam_periph_unlock(periph);
+	xpt_action(start_ccb);
+	cam_periph_lock(periph);
+
+	/* May have more work to do, so ensure we stay scheduled */
+	sddaschedule(periph);
+}
+
+static void
+sddadone(struct cam_periph *periph, union ccb *done_ccb)
+{
+	struct bio *bp;
+	struct sdda_softc *softc;
+	struct ccb_mmcio *mmcio;
+	struct cam_path *path;
+	uint32_t card_status;
+	int error = 0;
+
+	softc = (struct sdda_softc *)periph->softc;
+	mmcio = &done_ccb->mmcio;
+	path = done_ccb->ccb_h.path;
+
+	CAM_DEBUG(path, CAM_DEBUG_TRACE, ("sddadone\n"));
+//        cam_periph_lock(periph);
+	if ((done_ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		CAM_DEBUG(path, CAM_DEBUG_TRACE, ("Error!!!\n"));
+		if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0)
+			cam_release_devq(path,
+			    /*relsim_flags*/0,
+			    /*reduction*/0,
+			    /*timeout*/0,
+			    /*getcount_only*/0);
+		error = 5; /* EIO */
+	} else {
+		if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0)
+			panic("REQ_CMP with QFRZN");
+		error = 0;
+	}
+
+	card_status = mmcio->cmd.resp[0];
+	CAM_DEBUG(path, CAM_DEBUG_TRACE,
+	    ("Card status: %08x\n", R1_STATUS(card_status)));
+	CAM_DEBUG(path, CAM_DEBUG_TRACE,
+	    ("Current state: %d\n", R1_CURRENT_STATE(card_status)));
+
+	/* Process result of switching MMC partitions */
+	if (softc->state == SDDA_STATE_PART_SWITCH) {
+		CAM_DEBUG(path, CAM_DEBUG_TRACE,
+		    ("Compteting partition switch to %d\n", softc->part_requested));
+		softc->outstanding_cmds--;
+		/* Complete partition switch */
+		softc->state = SDDA_STATE_NORMAL;
+		if (error != MMC_ERR_NONE) {
+			/* TODO: Unpause retune if accessing RPMB */
+			xpt_release_ccb(done_ccb);
+			xpt_schedule(periph, CAM_PRIORITY_NORMAL);
+			return;
+		}
+
+		softc->raw_ext_csd[EXT_CSD_PART_CONFIG] =
+		    (softc->raw_ext_csd[EXT_CSD_PART_CONFIG] &
+			~EXT_CSD_PART_CONFIG_ACC_MASK) | softc->part_requested;
+		/* TODO: Unpause retune if accessing RPMB */
+		softc->part_curr = softc->part_requested;
+		xpt_release_ccb(done_ccb);
+
+		/* Return to processing BIO requests */
+		xpt_schedule(periph, CAM_PRIORITY_NORMAL);
+		return;
+	}
+
+	bp = (struct bio *)done_ccb->ccb_h.ccb_bp;
+	bp->bio_error = error;
+	if (error != 0) {
+		bp->bio_resid = bp->bio_bcount;
+		bp->bio_flags |= BIO_ERROR;
+	} else {
+		/* XXX: How many bytes remaining? */
+		bp->bio_resid = 0;
+		if (bp->bio_resid > 0)
+			bp->bio_flags |= BIO_ERROR;
+	}
+
+	softc->outstanding_cmds--;
+	xpt_release_ccb(done_ccb);
+	/*
+	 * Release the periph refcount taken in sddastart() for each CCB.
+	 */
+	KASSERT(softc->refcount >= 1, ("sddadone softc %p refcount %d", softc, softc->refcount));
+	softc->refcount--;
+	biodone(bp);
+}
+
+static int
+sddaerror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
+{
+	return(cam_periph_error(ccb, cam_flags, sense_flags));
+}
+#endif /* _KERNEL */
+
diff --git a/sys/cam/mmc/mmc_xpt.c b/sys/cam/mmc/mmc_xpt.c
new file mode 100644
index 00000000000..63836313804
--- /dev/null
+++ b/sys/cam/mmc/mmc_xpt.c
@@ -0,0 +1,1107 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2013,2014 Ilya Bakulin <ilya@bakulin.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/bus.h>
+#include <sys/endian.h>
+#include <sys/systm.h>
+#include <sys/types.h>
+#include <sys/malloc.h>
+#include <sys/kernel.h>
+#include <sys/time.h>
+#include <sys/conf.h>
+#include <sys/fcntl.h>
+#include <sys/interrupt.h>
+#include <sys/sbuf.h>
+
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/sysctl.h>
+#include <sys/condvar.h>
+
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <cam/cam_queue.h>
+#include <cam/cam_periph.h>
+#include <cam/cam_sim.h>
+#include <cam/cam_xpt.h>
+#include <cam/cam_xpt_sim.h>
+#include <cam/cam_xpt_periph.h>
+#include <cam/cam_xpt_internal.h>
+#include <cam/cam_debug.h>
+
+#include <cam/mmc/mmc.h>
+#include <cam/mmc/mmc_bus.h>
+
+#include <machine/stdarg.h>	/* for xpt_print below */
+#include <machine/_inttypes.h>  /* for PRIu64 */
+#include "opt_cam.h"
+
+FEATURE(mmccam, "CAM-based MMC/SD/SDIO stack");
+
+static struct cam_ed * mmc_alloc_device(struct cam_eb *bus,
+    struct cam_et *target, lun_id_t lun_id);
+static void mmc_dev_async(u_int32_t async_code, struct cam_eb *bus,
+    struct cam_et *target, struct cam_ed *device, void *async_arg);
+static void	 mmc_action(union ccb *start_ccb);
+static void	 mmc_dev_advinfo(union ccb *start_ccb);
+static void	 mmc_announce_periph(struct cam_periph *periph);
+static void	 mmc_scan_lun(struct cam_periph *periph,
+    struct cam_path *path, cam_flags flags, union ccb *ccb);
+
+/* mmcprobe methods */
+static cam_status mmcprobe_register(struct cam_periph *periph, void *arg);
+static void	 mmcprobe_start(struct cam_periph *periph, union ccb *start_ccb);
+static void	 mmcprobe_cleanup(struct cam_periph *periph);
+static void	 mmcprobe_done(struct cam_periph *periph, union ccb *done_ccb);
+
+static void mmc_proto_announce(struct cam_ed *device);
+static void mmc_proto_denounce(struct cam_ed *device);
+static void mmc_proto_debug_out(union ccb *ccb);
+
+typedef enum {
+	PROBE_RESET,
+	PROBE_IDENTIFY,
+        PROBE_SDIO_RESET,
+	PROBE_SEND_IF_COND,
+        PROBE_SDIO_INIT,
+        PROBE_MMC_INIT,
+	PROBE_SEND_APP_OP_COND,
+        PROBE_GET_CID,
+        PROBE_GET_CSD,
+        PROBE_SEND_RELATIVE_ADDR,
+	PROBE_MMC_SET_RELATIVE_ADDR,
+        PROBE_SELECT_CARD,
+	PROBE_DONE,
+	PROBE_INVALID
+} probe_action;
+
+static char *probe_action_text[] = {
+	"PROBE_RESET",
+	"PROBE_IDENTIFY",
+        "PROBE_SDIO_RESET",
+	"PROBE_SEND_IF_COND",
+        "PROBE_SDIO_INIT",
+        "PROBE_MMC_INIT",
+	"PROBE_SEND_APP_OP_COND",
+        "PROBE_GET_CID",
+        "PROBE_GET_CSD",
+        "PROBE_SEND_RELATIVE_ADDR",
+	"PROBE_MMC_SET_RELATIVE_ADDR",
+        "PROBE_SELECT_CARD",
+	"PROBE_DONE",
+	"PROBE_INVALID"
+};
+
+#define PROBE_SET_ACTION(softc, newaction)	\
+do {									\
+	char **text;							\
+	text = probe_action_text;					\
+	CAM_DEBUG((softc)->periph->path, CAM_DEBUG_PROBE,		\
+	    ("Probe %s to %s\n", text[(softc)->action],			\
+	    text[(newaction)]));					\
+	(softc)->action = (newaction);					\
+} while(0)
+
+static struct xpt_xport_ops mmc_xport_ops = {
+	.alloc_device = mmc_alloc_device,
+	.action = mmc_action,
+	.async = mmc_dev_async,
+	.announce = mmc_announce_periph,
+};
+
+#define MMC_XPT_XPORT(x, X)				\
+	static struct xpt_xport mmc_xport_ ## x = {	\
+		.xport = XPORT_ ## X,			\
+		.name = #x,				\
+		.ops = &mmc_xport_ops,			\
+	};						\
+	CAM_XPT_XPORT(mmc_xport_ ## x);
+
+MMC_XPT_XPORT(mmc, MMCSD);
+
+static struct xpt_proto_ops mmc_proto_ops = {
+	.announce = mmc_proto_announce,
+	.denounce = mmc_proto_denounce,
+	.debug_out = mmc_proto_debug_out,
+};
+
+static struct xpt_proto mmc_proto = {
+	.proto = PROTO_MMCSD,
+	.name = "mmcsd",
+	.ops = &mmc_proto_ops,
+};
+CAM_XPT_PROTO(mmc_proto);
+
+typedef struct {
+	probe_action	action;
+	int             restart;
+	union ccb	saved_ccb;
+	uint32_t	flags;
+#define PROBE_FLAG_ACMD_SENT	0x1 /* CMD55 is sent, card expects ACMD */
+	uint8_t         acmd41_count; /* how many times ACMD41 has been issued */
+	struct cam_periph *periph;
+} mmcprobe_softc;
+
+/* XPort functions -- an interface to CAM at periph side */
+
+static struct cam_ed *
+mmc_alloc_device(struct cam_eb *bus, struct cam_et *target, lun_id_t lun_id)
+{
+	struct cam_ed *device;
+
+	printf("mmc_alloc_device()\n");
+	device = xpt_alloc_device(bus, target, lun_id);
+	if (device == NULL)
+		return (NULL);
+
+	device->quirk = NULL;
+	device->mintags = 0;
+	device->maxtags = 0;
+	bzero(&device->inq_data, sizeof(device->inq_data));
+	device->inq_flags = 0;
+	device->queue_flags = 0;
+	device->serial_num = NULL;
+	device->serial_num_len = 0;
+	return (device);
+}
+
+static void
+mmc_dev_async(u_int32_t async_code, struct cam_eb *bus, struct cam_et *target,
+	      struct cam_ed *device, void *async_arg)
+{
+
+	printf("mmc_dev_async(async_code=0x%x, path_id=%d, target_id=%x, lun_id=%" SCNx64 "\n",
+	       async_code,
+	       bus->path_id,
+	       target->target_id,
+	       device->lun_id);
+	/*
+	 * We only need to handle events for real devices.
+	 */
+	if (target->target_id == CAM_TARGET_WILDCARD
+            || device->lun_id == CAM_LUN_WILDCARD)
+		return;
+
+        if (async_code == AC_LOST_DEVICE) {
+                if ((device->flags & CAM_DEV_UNCONFIGURED) == 0) {
+                        printf("AC_LOST_DEVICE -> set to unconfigured\n");
+                        device->flags |= CAM_DEV_UNCONFIGURED;
+                        xpt_release_device(device);
+                } else {
+                        printf("AC_LOST_DEVICE on unconfigured device\n");
+                }
+        } else if (async_code == AC_FOUND_DEVICE) {
+                printf("Got AC_FOUND_DEVICE -- whatever...\n");
+        } else if (async_code == AC_PATH_REGISTERED) {
+                printf("Got AC_PATH_REGISTERED -- whatever...\n");
+        } else if (async_code == AC_PATH_DEREGISTERED ) {
+                        printf("Got AC_PATH_DEREGISTERED -- whatever...\n");
+	} else if (async_code == AC_UNIT_ATTENTION) {
+		printf("Got interrupt generated by the card and ignored it\n");
+	} else
+		panic("Unknown async code\n");
+}
+
+/* Taken from nvme_scan_lun, thanks to bsdimp@ */
+static void
+mmc_scan_lun(struct cam_periph *periph, struct cam_path *path,
+	     cam_flags flags, union ccb *request_ccb)
+{
+	struct ccb_pathinq cpi;
+	cam_status status;
+	struct cam_periph *old_periph;
+	int lock;
+
+	CAM_DEBUG(path, CAM_DEBUG_TRACE, ("mmc_scan_lun\n"));
+
+	xpt_path_inq(&cpi, path);
+
+	if (cpi.ccb_h.status != CAM_REQ_CMP) {
+		if (request_ccb != NULL) {
+			request_ccb->ccb_h.status = cpi.ccb_h.status;
+			xpt_done(request_ccb);
+		}
+		return;
+	}
+
+	if (xpt_path_lun_id(path) == CAM_LUN_WILDCARD) {
+		CAM_DEBUG(path, CAM_DEBUG_TRACE, ("mmd_scan_lun ignoring bus\n"));
+		request_ccb->ccb_h.status = CAM_REQ_CMP;	/* XXX signal error ? */
+		xpt_done(request_ccb);
+		return;
+	}
+
+	lock = (xpt_path_owned(path) == 0);
+	if (lock)
+		xpt_path_lock(path);
+
+	if ((old_periph = cam_periph_find(path, "mmcprobe")) != NULL) {
+		if ((old_periph->flags & CAM_PERIPH_INVALID) == 0) {
+//			mmcprobe_softc *softc;
+//			softc = (mmcprobe_softc *)old_periph->softc;
+//                      Not sure if we need request ccb queue for mmc
+//			TAILQ_INSERT_TAIL(&softc->request_ccbs,
+//				&request_ccb->ccb_h, periph_links.tqe);
+//			softc->restart = 1;
+                        CAM_DEBUG(path, CAM_DEBUG_INFO,
+                                  ("Got scan request, but mmcprobe already exists\n"));
+			request_ccb->ccb_h.status = CAM_REQ_CMP_ERR;
+                        xpt_done(request_ccb);
+		} else {
+			request_ccb->ccb_h.status = CAM_REQ_CMP_ERR;
+			xpt_done(request_ccb);
+		}
+	} else {
+		xpt_print(path, " Set up the mmcprobe device...\n");
+
+                status = cam_periph_alloc(mmcprobe_register, NULL,
+					  mmcprobe_cleanup,
+					  mmcprobe_start,
+					  "mmcprobe",
+					  CAM_PERIPH_BIO,
+					  path, NULL, 0,
+					  request_ccb);
+                if (status != CAM_REQ_CMP) {
+			xpt_print(path, "xpt_scan_lun: cam_alloc_periph "
+                                  "returned an error, can't continue probe\n");
+		}
+		request_ccb->ccb_h.status = status;
+		xpt_done(request_ccb);
+	}
+
+	if (lock)
+		xpt_path_unlock(path);
+}
+
+static void
+mmc_action(union ccb *start_ccb)
+{
+	CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_TRACE,
+		  ("mmc_action! func_code=%x, action %s\n", start_ccb->ccb_h.func_code,
+		   xpt_action_name(start_ccb->ccb_h.func_code)));
+	switch (start_ccb->ccb_h.func_code) {
+
+	case XPT_SCAN_BUS:
+                /* FALLTHROUGH */
+	case XPT_SCAN_TGT:
+                /* FALLTHROUGH */
+	case XPT_SCAN_LUN:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_INFO,
+			  ("XPT_SCAN_{BUS,TGT,LUN}\n"));
+		mmc_scan_lun(start_ccb->ccb_h.path->periph,
+			     start_ccb->ccb_h.path, start_ccb->crcn.flags,
+			     start_ccb);
+		break;
+
+	case XPT_DEV_ADVINFO:
+	{
+		mmc_dev_advinfo(start_ccb);
+		break;
+	}
+
+	default:
+		xpt_action_default(start_ccb);
+		break;
+	}
+}
+
+static void
+mmc_dev_advinfo(union ccb *start_ccb)
+{
+	struct cam_ed *device;
+	struct ccb_dev_advinfo *cdai;
+	off_t amt;
+
+	start_ccb->ccb_h.status = CAM_REQ_INVALID;
+	device = start_ccb->ccb_h.path->device;
+	cdai = &start_ccb->cdai;
+	CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_TRACE,
+		  ("%s: request %x\n", __func__, cdai->buftype));
+
+        /* We don't support writing any data */
+        if (cdai->flags & CDAI_FLAG_STORE)
+                panic("Attempt to store data?!");
+
+	switch(cdai->buftype) {
+	case CDAI_TYPE_SCSI_DEVID:
+		cdai->provsiz = device->device_id_len;
+		if (device->device_id_len == 0)
+			break;
+		amt = MIN(cdai->provsiz, cdai->bufsiz);
+		memcpy(cdai->buf, device->device_id, amt);
+		break;
+	case CDAI_TYPE_SERIAL_NUM:
+		cdai->provsiz = device->serial_num_len;
+		if (device->serial_num_len == 0)
+			break;
+		amt = MIN(cdai->provsiz, cdai->bufsiz);
+		memcpy(cdai->buf, device->serial_num, amt);
+		break;
+        case CDAI_TYPE_PHYS_PATH: /* pass(4) wants this */
+                cdai->provsiz = 0;
+                break;
+	case CDAI_TYPE_MMC_PARAMS:
+		cdai->provsiz = sizeof(struct mmc_params);
+		amt = MIN(cdai->provsiz, cdai->bufsiz);
+		memcpy(cdai->buf, &device->mmc_ident_data, amt);
+		break;
+	default:
+                panic("Unknown buftype");
+		return;
+	}
+	start_ccb->ccb_h.status = CAM_REQ_CMP;
+}
+
+static void
+mmc_announce_periph(struct cam_periph *periph)
+{
+	struct	ccb_pathinq cpi;
+	struct	ccb_trans_settings cts;
+	struct	cam_path *path = periph->path;
+
+	cam_periph_assert(periph, MA_OWNED);
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_INFO,
+		  ("mmc_announce_periph: called\n"));
+
+	xpt_setup_ccb(&cts.ccb_h, path, CAM_PRIORITY_NORMAL);
+	cts.ccb_h.func_code = XPT_GET_TRAN_SETTINGS;
+	cts.type = CTS_TYPE_CURRENT_SETTINGS;
+	xpt_action((union ccb*)&cts);
+	if ((cts.ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)
+		return;
+	xpt_path_inq(&cpi, periph->path);
+	printf("XPT info: CLK %04X, ...\n", cts.proto_specific.mmc.ios.clock);
+}
+
+/* This func is called per attached device :-( */
+void
+mmc_print_ident(struct mmc_params *ident_data)
+{
+        printf("Relative addr: %08x\n", ident_data->card_rca);
+        printf("Card features: <");
+        if (ident_data->card_features & CARD_FEATURE_MMC)
+                printf("MMC ");
+        if (ident_data->card_features & CARD_FEATURE_MEMORY)
+                printf("Memory ");
+        if (ident_data->card_features & CARD_FEATURE_SDHC)
+                printf("High-Capacity ");
+        if (ident_data->card_features & CARD_FEATURE_SD20)
+                printf("SD2.0-Conditions ");
+        if (ident_data->card_features & CARD_FEATURE_SDIO)
+                printf("SDIO ");
+        printf(">\n");
+
+        if (ident_data->card_features & CARD_FEATURE_MEMORY)
+                printf("Card memory OCR: %08x\n", ident_data->card_ocr);
+
+        if (ident_data->card_features & CARD_FEATURE_SDIO) {
+                printf("Card IO OCR: %08x\n", ident_data->io_ocr);
+                printf("Number of funcitions: %u\n", ident_data->sdio_func_count);
+        }
+}
+
+static void
+mmc_proto_announce(struct cam_ed *device)
+{
+	mmc_print_ident(&device->mmc_ident_data);
+}
+
+static void
+mmc_proto_denounce(struct cam_ed *device)
+{
+	mmc_print_ident(&device->mmc_ident_data);
+}
+
+static void
+mmc_proto_debug_out(union ccb *ccb)
+{
+	if (ccb->ccb_h.func_code != XPT_MMC_IO)
+		return;
+
+	CAM_DEBUG(ccb->ccb_h.path,
+	    CAM_DEBUG_CDB,("mmc_proto_debug_out\n"));
+}
+
+static periph_init_t probe_periph_init;
+
+static struct periph_driver probe_driver =
+{
+	probe_periph_init, "mmcprobe",
+	TAILQ_HEAD_INITIALIZER(probe_driver.units), /* generation */ 0,
+	CAM_PERIPH_DRV_EARLY
+};
+
+PERIPHDRIVER_DECLARE(mmcprobe, probe_driver);
+
+#define	CARD_ID_FREQUENCY 400000 /* Spec requires 400kHz max during ID phase. */
+
+static void
+probe_periph_init()
+{
+}
+
+static cam_status
+mmcprobe_register(struct cam_periph *periph, void *arg)
+{
+	mmcprobe_softc *softc;
+	union ccb *request_ccb;	/* CCB representing the probe request */
+	cam_status status;
+
+	CAM_DEBUG(periph->path, CAM_DEBUG_TRACE, ("mmcprobe_register\n"));
+
+	request_ccb = (union ccb *)arg;
+	if (request_ccb == NULL) {
+		printf("mmcprobe_register: no probe CCB, "
+		       "can't register device\n");
+		return(CAM_REQ_CMP_ERR);
+	}
+
+	softc = (mmcprobe_softc *)malloc(sizeof(*softc), M_CAMXPT, M_NOWAIT);
+
+	if (softc == NULL) {
+		printf("proberegister: Unable to probe new device. "
+		       "Unable to allocate softc\n");
+		return(CAM_REQ_CMP_ERR);
+	}
+
+	softc->flags = 0;
+	softc->acmd41_count = 0;
+	periph->softc = softc;
+	softc->periph = periph;
+	softc->action = PROBE_INVALID;
+        softc->restart = 0;
+	status = cam_periph_acquire(periph);
+
+        memset(&periph->path->device->mmc_ident_data, 0, sizeof(struct mmc_params));
+	if (status != CAM_REQ_CMP) {
+		printf("proberegister: cam_periph_acquire failed (status=%d)\n",
+			status);
+		return (status);
+	}
+	CAM_DEBUG(periph->path, CAM_DEBUG_PROBE, ("Probe started\n"));
+
+	if (periph->path->device->flags & CAM_DEV_UNCONFIGURED)
+		PROBE_SET_ACTION(softc, PROBE_RESET);
+	else
+		PROBE_SET_ACTION(softc, PROBE_IDENTIFY);
+
+	/* This will kick the ball */
+	xpt_schedule(periph, CAM_PRIORITY_XPT);
+
+	return(CAM_REQ_CMP);
+}
+
+static int
+mmc_highest_voltage(uint32_t ocr)
+{
+	int i;
+
+	for (i = MMC_OCR_MAX_VOLTAGE_SHIFT;
+	    i >= MMC_OCR_MIN_VOLTAGE_SHIFT; i--)
+		if (ocr & (1 << i))
+			return (i);
+	return (-1);
+}
+
+static inline void
+init_standard_ccb(union ccb *ccb, uint32_t cmd)
+{
+	ccb->ccb_h.func_code = cmd;
+	ccb->ccb_h.flags = CAM_DIR_OUT;
+	ccb->ccb_h.retry_count = 0;
+	ccb->ccb_h.timeout = 15 * 1000;
+	ccb->ccb_h.cbfcnp = mmcprobe_done;
+}
+
+static void
+mmcprobe_start(struct cam_periph *periph, union ccb *start_ccb)
+{
+	mmcprobe_softc *softc;
+	struct cam_path *path;
+	struct ccb_mmcio *mmcio;
+	struct mtx *p_mtx = cam_periph_mtx(periph);
+	struct ccb_trans_settings_mmc *cts;
+
+	CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("mmcprobe_start\n"));
+	softc = (mmcprobe_softc *)periph->softc;
+	path = start_ccb->ccb_h.path;
+	mmcio = &start_ccb->mmcio;
+	cts = &start_ccb->cts.proto_specific.mmc;
+	struct mmc_params *mmcp = &path->device->mmc_ident_data;
+
+	memset(&mmcio->cmd, 0, sizeof(struct mmc_command));
+
+	if (softc->restart) {
+		softc->restart = 0;
+		if (path->device->flags & CAM_DEV_UNCONFIGURED)
+			softc->action = PROBE_RESET;
+		else
+			softc->action = PROBE_IDENTIFY;
+
+	}
+
+	/* Here is the place where the identify fun begins */
+	switch (softc->action) {
+	case PROBE_RESET:
+		/* FALLTHROUGH */
+	case PROBE_IDENTIFY:
+		xpt_path_inq(&start_ccb->cpi, periph->path);
+
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("Start with PROBE_RESET\n"));
+		init_standard_ccb(start_ccb, XPT_GET_TRAN_SETTINGS);
+		xpt_action(start_ccb);
+		if(cts->ios.power_mode != power_off) {
+			init_standard_ccb(start_ccb, XPT_SET_TRAN_SETTINGS);
+			cts->ios.power_mode = power_off;
+			cts->ios_valid = MMC_PM;
+			xpt_action(start_ccb);
+			mtx_sleep(periph, p_mtx, 0, "mmcios", 100);
+		}
+
+		/* mmc_power_up */
+		/* Get the host OCR */
+		init_standard_ccb(start_ccb, XPT_GET_TRAN_SETTINGS);
+		xpt_action(start_ccb);
+
+		uint32_t hv = mmc_highest_voltage(cts->host_ocr);
+		init_standard_ccb(start_ccb, XPT_SET_TRAN_SETTINGS);
+		cts->ios.vdd = hv;
+		cts->ios.bus_mode = opendrain;
+		cts->ios.chip_select = cs_dontcare;
+		cts->ios.power_mode = power_up;
+		cts->ios.bus_width = bus_width_1;
+		cts->ios.clock = 0;
+		cts->ios_valid = MMC_VDD | MMC_PM | MMC_BM |
+			MMC_CS | MMC_BW | MMC_CLK;
+		xpt_action(start_ccb);
+		mtx_sleep(periph, p_mtx, 0, "mmcios", 100);
+
+		init_standard_ccb(start_ccb, XPT_SET_TRAN_SETTINGS);
+		cts->ios.power_mode = power_on;
+		cts->ios.clock = CARD_ID_FREQUENCY;
+		cts->ios.timing = bus_timing_normal;
+		cts->ios_valid = MMC_PM | MMC_CLK | MMC_BT;
+		xpt_action(start_ccb);
+		mtx_sleep(periph, p_mtx, 0, "mmcios", 100);
+		/* End for mmc_power_on */
+
+		/* Begin mmc_idle_cards() */
+		init_standard_ccb(start_ccb, XPT_SET_TRAN_SETTINGS);
+		cts->ios.chip_select = cs_high;
+		cts->ios_valid = MMC_CS;
+		xpt_action(start_ccb);
+		mtx_sleep(periph, p_mtx, 0, "mmcios", 1);
+
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("Send first XPT_MMC_IO\n"));
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = MMC_GO_IDLE_STATE; /* CMD 0 */
+		mmcio->cmd.arg = 0;
+		mmcio->cmd.flags = MMC_RSP_NONE | MMC_CMD_BC;
+		mmcio->cmd.data = NULL;
+		mmcio->stop.opcode = 0;
+
+		/* XXX Reset I/O portion as well */
+		break;
+	case PROBE_SDIO_RESET:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			  ("Start with PROBE_SDIO_RESET\n"));
+		uint32_t mmc_arg = SD_IO_RW_ADR(SD_IO_CCCR_CTL)
+			| SD_IO_RW_DAT(CCCR_CTL_RES) | SD_IO_RW_WR | SD_IO_RW_RAW;
+		cam_fill_mmcio(&start_ccb->mmcio,
+			       /*retries*/ 0,
+			       /*cbfcnp*/ mmcprobe_done,
+			       /*flags*/ CAM_DIR_NONE,
+			       /*mmc_opcode*/ SD_IO_RW_DIRECT,
+			       /*mmc_arg*/ mmc_arg,
+			       /*mmc_flags*/ MMC_RSP_R5 | MMC_CMD_AC,
+			       /*mmc_data*/ NULL,
+			       /*timeout*/ 1000);
+		break;
+	case PROBE_SEND_IF_COND:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			  ("Start with PROBE_SEND_IF_COND\n"));
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = SD_SEND_IF_COND; /* CMD 8 */
+		mmcio->cmd.arg = (1 << 8) + 0xAA;
+		mmcio->cmd.flags = MMC_RSP_R7 | MMC_CMD_BCR;
+		mmcio->stop.opcode = 0;
+		break;
+
+	case PROBE_SDIO_INIT:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			  ("Start with PROBE_SDIO_INIT\n"));
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = IO_SEND_OP_COND; /* CMD 5 */
+		mmcio->cmd.arg = mmcp->io_ocr;
+		mmcio->cmd.flags = MMC_RSP_R4;
+		mmcio->stop.opcode = 0;
+		break;
+
+	case PROBE_MMC_INIT:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			  ("Start with PROBE_MMC_INIT\n"));
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = MMC_SEND_OP_COND; /* CMD 1 */
+		mmcio->cmd.arg = MMC_OCR_CCS | mmcp->card_ocr; /* CCS + ocr */;
+		mmcio->cmd.flags = MMC_RSP_R3 | MMC_CMD_BCR;
+		mmcio->stop.opcode = 0;
+		break;
+
+	case PROBE_SEND_APP_OP_COND:
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		if (softc->flags & PROBE_FLAG_ACMD_SENT) {
+			mmcio->cmd.opcode = ACMD_SD_SEND_OP_COND; /* CMD 41 */
+			/*
+			 * We set CCS bit because we do support SDHC cards.
+			 * XXX: Don't set CCS if no response to CMD8.
+			 */
+			uint32_t cmd_arg = MMC_OCR_CCS | mmcp->card_ocr; /* CCS + ocr */
+			if (softc->acmd41_count < 10 && mmcp->card_ocr != 0 )
+				cmd_arg |= MMC_OCR_S18R;
+			mmcio->cmd.arg = cmd_arg;
+			mmcio->cmd.flags = MMC_RSP_R3 | MMC_CMD_BCR;
+			softc->acmd41_count++;
+		} else {
+			mmcio->cmd.opcode = MMC_APP_CMD; /* CMD 55 */
+			mmcio->cmd.arg = 0; /* rca << 16 */
+			mmcio->cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		}
+		mmcio->stop.opcode = 0;
+		break;
+
+	case PROBE_GET_CID: /* XXX move to mmc_da */
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = MMC_ALL_SEND_CID;
+		mmcio->cmd.arg = 0;
+		mmcio->cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
+		mmcio->stop.opcode = 0;
+		break;
+	case PROBE_SEND_RELATIVE_ADDR:
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = SD_SEND_RELATIVE_ADDR;
+		mmcio->cmd.arg = 0;
+		mmcio->cmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;
+		mmcio->stop.opcode = 0;
+		break;
+	case PROBE_MMC_SET_RELATIVE_ADDR:
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = MMC_SET_RELATIVE_ADDR;
+		mmcio->cmd.arg = MMC_PROPOSED_RCA << 16;
+		mmcio->cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		mmcio->stop.opcode = 0;
+		break;
+	case PROBE_SELECT_CARD:
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = MMC_SELECT_CARD;
+		mmcio->cmd.arg = (uint32_t)path->device->mmc_ident_data.card_rca << 16;
+		mmcio->cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
+		mmcio->stop.opcode = 0;
+		break;
+	case PROBE_GET_CSD: /* XXX move to mmc_da */
+		init_standard_ccb(start_ccb, XPT_MMC_IO);
+		mmcio->cmd.opcode = MMC_SEND_CSD;
+		mmcio->cmd.arg = (uint32_t)path->device->mmc_ident_data.card_rca << 16;
+		mmcio->cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
+		mmcio->stop.opcode = 0;
+		break;
+	case PROBE_DONE:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("Start with PROBE_DONE\n"));
+		init_standard_ccb(start_ccb, XPT_SET_TRAN_SETTINGS);
+		cts->ios.bus_mode = pushpull;
+		cts->ios_valid = MMC_BM;
+		xpt_action(start_ccb);
+		return;
+		/* NOTREACHED */
+		break;
+	case PROBE_INVALID:
+		break;
+	default:
+		CAM_DEBUG(start_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("probestart: invalid action state 0x%x\n", softc->action));
+		panic("default: case in mmc_probe_start()");
+	}
+
+	start_ccb->ccb_h.flags |= CAM_DEV_QFREEZE;
+	xpt_action(start_ccb);
+}
+
+static void mmcprobe_cleanup(struct cam_periph *periph)
+{
+	free(periph->softc, M_CAMXPT);
+}
+
+static void
+mmcprobe_done(struct cam_periph *periph, union ccb *done_ccb)
+{
+	mmcprobe_softc *softc;
+	struct cam_path *path;
+
+	int err;
+	struct ccb_mmcio *mmcio;
+	u_int32_t  priority;
+
+	CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("mmcprobe_done\n"));
+	softc = (mmcprobe_softc *)periph->softc;
+	path = done_ccb->ccb_h.path;
+	priority = done_ccb->ccb_h.pinfo.priority;
+
+	switch (softc->action) {
+	case PROBE_RESET:
+		/* FALLTHROUGH */
+	case PROBE_IDENTIFY:
+	{
+		printf("Starting completion of PROBE_RESET\n");
+		CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE, ("done with PROBE_RESET\n"));
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("GO_IDLE_STATE failed with error %d\n",
+				   err));
+
+			/* There was a device there, but now it's gone... */
+			if ((path->device->flags & CAM_DEV_UNCONFIGURED) == 0) {
+				xpt_async(AC_LOST_DEVICE, path, NULL);
+			}
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+			break;
+		}
+		path->device->protocol = PROTO_MMCSD;
+		PROBE_SET_ACTION(softc, PROBE_SEND_IF_COND);
+		break;
+	}
+	case PROBE_SEND_IF_COND:
+	{
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+		struct mmc_params *mmcp = &path->device->mmc_ident_data;
+
+		if (err != MMC_ERR_NONE || mmcio->cmd.resp[0] != 0x1AA) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("IF_COND: error %d, pattern %08x\n",
+				   err, mmcio->cmd.resp[0]));
+		} else {
+			mmcp->card_features |= CARD_FEATURE_SD20;
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("SD 2.0 interface conditions: OK\n"));
+
+		}
+                PROBE_SET_ACTION(softc, PROBE_SDIO_RESET);
+		break;
+	}
+        case PROBE_SDIO_RESET:
+        {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("SDIO_RESET: error %d, CCCR CTL register: %08x\n",
+                           err, mmcio->cmd.resp[0]));
+                PROBE_SET_ACTION(softc, PROBE_SDIO_INIT);
+                break;
+        }
+        case PROBE_SDIO_INIT:
+        {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+                struct mmc_params *mmcp = &path->device->mmc_ident_data;
+
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("SDIO_INIT: error %d, %08x %08x %08x %08x\n",
+                           err, mmcio->cmd.resp[0],
+                           mmcio->cmd.resp[1],
+                           mmcio->cmd.resp[2],
+                           mmcio->cmd.resp[3]));
+
+                /*
+                 * Error here means that this card is not SDIO,
+                 * so proceed with memory init as if nothing has happened
+                 */
+		if (err != MMC_ERR_NONE) {
+                        PROBE_SET_ACTION(softc, PROBE_SEND_APP_OP_COND);
+                        break;
+		}
+                mmcp->card_features |= CARD_FEATURE_SDIO;
+                uint32_t ioifcond = mmcio->cmd.resp[0];
+                uint32_t io_ocr = ioifcond & R4_IO_OCR_MASK;
+
+                mmcp->sdio_func_count = R4_IO_NUM_FUNCTIONS(ioifcond);
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("SDIO card: %d functions\n", mmcp->sdio_func_count));
+                if (io_ocr == 0) {
+                    CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                              ("SDIO OCR invalid?!\n"));
+                    break; /* Retry */
+                }
+
+                if (io_ocr != 0 && mmcp->io_ocr == 0) {
+                        mmcp->io_ocr = io_ocr;
+                        break; /* Retry, this time with non-0 OCR */
+                }
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("SDIO OCR: %08x\n", mmcp->io_ocr));
+
+                if (ioifcond & R4_IO_MEM_PRESENT) {
+                        /* Combo card -- proceed to memory initialization */
+                        PROBE_SET_ACTION(softc, PROBE_SEND_APP_OP_COND);
+                } else {
+                        /* No memory portion -- get RCA and select card */
+                        PROBE_SET_ACTION(softc, PROBE_SEND_RELATIVE_ADDR);
+                }
+                break;
+        }
+        case PROBE_MMC_INIT:
+        {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+                struct mmc_params *mmcp = &path->device->mmc_ident_data;
+
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("MMC_INIT: error %d, resp %08x\n",
+				   err, mmcio->cmd.resp[0]));
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+                        break;
+                }
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("MMC card, OCR %08x\n", mmcio->cmd.resp[0]));
+
+                if (mmcp->card_ocr == 0) {
+                        /* We haven't sent the OCR to the card yet -- do it */
+                        mmcp->card_ocr = mmcio->cmd.resp[0];
+                        CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                                  ("-> sending OCR to card\n"));
+                        break;
+                }
+
+                if (!(mmcio->cmd.resp[0] & MMC_OCR_CARD_BUSY)) {
+                        CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                                  ("Card is still powering up\n"));
+                        break;
+                }
+
+                mmcp->card_features |= CARD_FEATURE_MMC | CARD_FEATURE_MEMORY;
+                PROBE_SET_ACTION(softc, PROBE_GET_CID);
+                break;
+        }
+	case PROBE_SEND_APP_OP_COND:
+	{
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("APP_OP_COND: error %d, resp %08x\n",
+				   err, mmcio->cmd.resp[0]));
+			PROBE_SET_ACTION(softc, PROBE_MMC_INIT);
+                        break;
+                }
+
+                if (!(softc->flags & PROBE_FLAG_ACMD_SENT)) {
+                        /* Don't change the state */
+                        softc->flags |= PROBE_FLAG_ACMD_SENT;
+                        break;
+                }
+
+                softc->flags &= ~PROBE_FLAG_ACMD_SENT;
+                if ((mmcio->cmd.resp[0] & MMC_OCR_CARD_BUSY) ||
+                    (mmcio->cmd.arg & MMC_OCR_VOLTAGE) == 0) {
+                        struct mmc_params *mmcp = &path->device->mmc_ident_data;
+                        CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                                  ("Card OCR: %08x\n",  mmcio->cmd.resp[0]));
+                        if (mmcp->card_ocr == 0) {
+                                mmcp->card_ocr = mmcio->cmd.resp[0];
+                                /* Now when we know OCR that we want -- send it to card */
+                                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                                          ("-> sending OCR to card\n"));
+                        } else {
+                                /* We already know the OCR and despite of that we
+                                 * are processing the answer to ACMD41 -> move on
+                                 */
+                                PROBE_SET_ACTION(softc, PROBE_GET_CID);
+                        }
+                        /* Getting an answer to ACMD41 means the card has memory */
+                        mmcp->card_features |= CARD_FEATURE_MEMORY;
+
+                        /* Standard capacity vs High Capacity memory card */
+                        if (mmcio->cmd.resp[0] & MMC_OCR_CCS) {
+                                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                                          ("Card is SDHC\n"));
+                                mmcp->card_features |= CARD_FEATURE_SDHC;
+                        }
+
+			/* Whether the card supports 1.8V signaling */
+			if (mmcio->cmd.resp[0] & MMC_OCR_S18A) {
+				CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+					  ("Card supports 1.8V signaling\n"));
+				mmcp->card_features |= CARD_FEATURE_18V;
+			}
+		} else {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("Card not ready: %08x\n",  mmcio->cmd.resp[0]));
+			/* Send CMD55+ACMD41 once again  */
+			PROBE_SET_ACTION(softc, PROBE_SEND_APP_OP_COND);
+		}
+
+                break;
+	}
+        case PROBE_GET_CID: /* XXX move to mmc_da */
+        {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("PROBE_GET_CID: error %d\n", err));
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+                        break;
+                }
+
+                struct mmc_params *mmcp = &path->device->mmc_ident_data;
+                memcpy(mmcp->card_cid, mmcio->cmd.resp, 4 * sizeof(uint32_t));
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("CID %08x%08x%08x%08x\n",
+                           mmcp->card_cid[0],
+                           mmcp->card_cid[1],
+                           mmcp->card_cid[2],
+                           mmcp->card_cid[3]));
+		if (mmcp->card_features & CARD_FEATURE_MMC)
+			PROBE_SET_ACTION(softc, PROBE_MMC_SET_RELATIVE_ADDR);
+		else
+                	PROBE_SET_ACTION(softc, PROBE_SEND_RELATIVE_ADDR);
+                break;
+        }
+        case PROBE_SEND_RELATIVE_ADDR: {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+                struct mmc_params *mmcp = &path->device->mmc_ident_data;
+                uint16_t rca = mmcio->cmd.resp[0] >> 16;
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("Card published RCA: %u\n", rca));
+                path->device->mmc_ident_data.card_rca = rca;
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("PROBE_SEND_RELATIVE_ADDR: error %d\n", err));
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+                        break;
+                }
+
+                /* If memory is present, get CSD, otherwise select card */
+                if (mmcp->card_features & CARD_FEATURE_MEMORY)
+                        PROBE_SET_ACTION(softc, PROBE_GET_CSD);
+                else
+                        PROBE_SET_ACTION(softc, PROBE_SELECT_CARD);
+		break;
+        }
+	case PROBE_MMC_SET_RELATIVE_ADDR:
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			    ("PROBE_MMC_SET_RELATIVE_ADDR: error %d\n", err));
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+			break;
+		}
+		path->device->mmc_ident_data.card_rca = MMC_PROPOSED_RCA;
+		PROBE_SET_ACTION(softc, PROBE_GET_CSD);
+		break;
+        case PROBE_GET_CSD: {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("PROBE_GET_CSD: error %d\n", err));
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+                        break;
+                }
+
+                struct mmc_params *mmcp = &path->device->mmc_ident_data;
+                memcpy(mmcp->card_csd, mmcio->cmd.resp, 4 * sizeof(uint32_t));
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+                          ("CSD %08x%08x%08x%08x\n",
+                           mmcp->card_csd[0],
+                           mmcp->card_csd[1],
+                           mmcp->card_csd[2],
+                           mmcp->card_csd[3]));
+                PROBE_SET_ACTION(softc, PROBE_SELECT_CARD);
+                break;
+        }
+        case PROBE_SELECT_CARD: {
+		mmcio = &done_ccb->mmcio;
+		err = mmcio->cmd.error;
+		if (err != MMC_ERR_NONE) {
+			CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+				  ("PROBE_SEND_RELATIVE_ADDR: error %d\n", err));
+			PROBE_SET_ACTION(softc, PROBE_INVALID);
+                        break;
+                }
+
+		PROBE_SET_ACTION(softc, PROBE_DONE);
+                break;
+        }
+	default:
+		CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			  ("mmc_probedone: invalid action state 0x%x\n", softc->action));
+		panic("default: case in mmc_probe_done()");
+	}
+
+        if (softc->action == PROBE_INVALID &&
+            (path->device->flags & CAM_DEV_UNCONFIGURED) == 0) {
+                CAM_DEBUG(done_ccb->ccb_h.path, CAM_DEBUG_PROBE,
+			  ("mmc_probedone: Should send AC_LOST_DEVICE but won't for now\n"));
+                //xpt_async(AC_LOST_DEVICE, path, NULL);
+        }
+
+	xpt_release_ccb(done_ccb);
+        if (softc->action != PROBE_INVALID)
+                xpt_schedule(periph, priority);
+	/* Drop freeze taken due to CAM_DEV_QFREEZE flag set. */
+	int frozen = cam_release_devq(path, 0, 0, 0, FALSE);
+        printf("mmc_probedone: remaining freezecnt %d\n", frozen);
+
+	if (softc->action == PROBE_DONE) {
+                /* Notify the system that the device is found! */
+		if (periph->path->device->flags & CAM_DEV_UNCONFIGURED) {
+			path->device->flags &= ~CAM_DEV_UNCONFIGURED;
+			xpt_acquire_device(path->device);
+			done_ccb->ccb_h.func_code = XPT_GDEV_TYPE;
+			xpt_action(done_ccb);
+			xpt_async(AC_FOUND_DEVICE, path, done_ccb);
+		}
+	}
+        if (softc->action == PROBE_DONE || softc->action == PROBE_INVALID) {
+                cam_periph_invalidate(periph);
+                cam_periph_release_locked(periph);
+        }
+}
diff --git a/sys/cam/nvme/nvme_da.c b/sys/cam/nvme/nvme_da.c
index 1aa9954747a..3018567b958 100644
--- a/sys/cam/nvme/nvme_da.c
+++ b/sys/cam/nvme/nvme_da.c
@@ -405,7 +405,7 @@ ndadump(void *arg, void *virtual, vm_offset_t physical, off_t offset, size_t len
 		xpt_polled_action(&ccb);
 
 		error = cam_periph_error(&ccb,
-		    0, SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+		    0, SF_NO_RECOVERY | SF_NO_RETRY);
 		if ((ccb.ccb_h.status & CAM_DEV_QFRZN) != 0)
 			cam_release_devq(ccb.ccb_h.path, /*relsim_flags*/0,
 			    /*reduction*/0, /*timeout*/0, /*getcount_only*/0);
@@ -424,7 +424,7 @@ ndadump(void *arg, void *virtual, vm_offset_t physical, off_t offset, size_t len
 	xpt_polled_action(&ccb);
 
 	error = cam_periph_error(&ccb,
-	    0, SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+	    0, SF_NO_RECOVERY | SF_NO_RETRY);
 	if ((ccb.ccb_h.status & CAM_DEV_QFRZN) != 0)
 		cam_release_devq(ccb.ccb_h.path, /*relsim_flags*/0,
 		    /*reduction*/0, /*timeout*/0, /*getcount_only*/0);
@@ -1090,7 +1090,7 @@ ndaerror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 		break;
 	}
 
-	return(cam_periph_error(ccb, cam_flags, sense_flags, NULL));
+	return(cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 /*
diff --git a/sys/cam/scsi/scsi_all.c b/sys/cam/scsi/scsi_all.c
index d7989dcf506..d1dd4acb9d4 100644
--- a/sys/cam/scsi/scsi_all.c
+++ b/sys/cam/scsi/scsi_all.c
@@ -35,7 +35,7 @@ __FBSDID("$FreeBSD$");
 #include <sys/stdint.h>
 
 #ifdef _KERNEL
-#include <opt_scsi.h>
+#include "opt_scsi.h"
 
 #include <sys/systm.h>
 #include <sys/libkern.h>
diff --git a/sys/cam/scsi/scsi_cd.c b/sys/cam/scsi/scsi_cd.c
index 4a9f44cd728..a2f57c593cc 100644
--- a/sys/cam/scsi/scsi_cd.c
+++ b/sys/cam/scsi/scsi_cd.c
@@ -2594,8 +2594,7 @@ cderror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 
 	if (softc->quirks & CD_Q_RETRY_BUSY)
 		sense_flags |= SF_RETRY_BUSY;
-	return (cam_periph_error(ccb, cam_flags, sense_flags, 
-				 &softc->saved_ccb));
+	return (cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 static void
diff --git a/sys/cam/scsi/scsi_ch.c b/sys/cam/scsi/scsi_ch.c
index 9271ebcb83b..7ee53560244 100644
--- a/sys/cam/scsi/scsi_ch.c
+++ b/sys/cam/scsi/scsi_ch.c
@@ -750,8 +750,7 @@ cherror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 	periph = xpt_path_periph(ccb->ccb_h.path);
 	softc = (struct ch_softc *)periph->softc;
 
-	return (cam_periph_error(ccb, cam_flags, sense_flags,
-				 &softc->saved_ccb));
+	return (cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 static int
diff --git a/sys/cam/scsi/scsi_da.c b/sys/cam/scsi/scsi_da.c
index 2162bb914a3..ebdf56ff554 100644
--- a/sys/cam/scsi/scsi_da.c
+++ b/sys/cam/scsi/scsi_da.c
@@ -1638,7 +1638,7 @@ dadump(void *arg, void *virtual, vm_offset_t physical, off_t offset, size_t leng
 		xpt_polled_action((union ccb *)&csio);
 
 		error = cam_periph_error((union ccb *)&csio,
-		    0, SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+		    0, SF_NO_RECOVERY | SF_NO_RETRY);
 		if ((csio.ccb_h.status & CAM_DEV_QFRZN) != 0)
 			cam_release_devq(csio.ccb_h.path, /*relsim_flags*/0,
 			    /*reduction*/0, /*timeout*/0, /*getcount_only*/0);
@@ -1666,7 +1666,7 @@ dadump(void *arg, void *virtual, vm_offset_t physical, off_t offset, size_t leng
 		xpt_polled_action((union ccb *)&csio);
 
 		error = cam_periph_error((union ccb *)&csio,
-		    0, SF_NO_RECOVERY | SF_NO_RETRY | SF_QUIET_IR, NULL);
+		    0, SF_NO_RECOVERY | SF_NO_RETRY | SF_QUIET_IR);
 		if ((csio.ccb_h.status & CAM_DEV_QFRZN) != 0)
 			cam_release_devq(csio.ccb_h.path, /*relsim_flags*/0,
 			    /*reduction*/0, /*timeout*/0, /*getcount_only*/0);
@@ -5375,8 +5375,7 @@ daerror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 
 	if (softc->quirks & DA_Q_RETRY_BUSY)
 		sense_flags |= SF_RETRY_BUSY;
-	return(cam_periph_error(ccb, cam_flags, sense_flags,
-				&softc->saved_ccb));
+	return(cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 static void
diff --git a/sys/cam/scsi/scsi_enc.c b/sys/cam/scsi/scsi_enc.c
index a450cd07715..9f1b242c788 100644
--- a/sys/cam/scsi/scsi_enc.c
+++ b/sys/cam/scsi/scsi_enc.c
@@ -56,7 +56,7 @@ __FBSDID("$FreeBSD$");
 #include <cam/scsi/scsi_enc.h>
 #include <cam/scsi/scsi_enc_internal.h>
 
-#include <opt_ses.h>
+#include "opt_ses.h"
 
 MALLOC_DEFINE(M_SCSIENC, "SCSI ENC", "SCSI ENC buffers");
 
@@ -332,7 +332,7 @@ enc_error(union ccb *ccb, uint32_t cflags, uint32_t sflags)
 	periph = xpt_path_periph(ccb->ccb_h.path);
 	softc = (struct enc_softc *)periph->softc;
 
-	return (cam_periph_error(ccb, cflags, sflags, &softc->saved_ccb));
+	return (cam_periph_error(ccb, cflags, sflags));
 }
 
 static int
diff --git a/sys/cam/scsi/scsi_pass.c b/sys/cam/scsi/scsi_pass.c
index aa13a01d115..7cd6c418cd2 100644
--- a/sys/cam/scsi/scsi_pass.c
+++ b/sys/cam/scsi/scsi_pass.c
@@ -2202,7 +2202,7 @@ passsendccb(struct cam_periph *periph, union ccb *ccb, union ccb *inccb)
 	 */
 	fc = ccb->ccb_h.func_code;
 	if ((fc == XPT_SCSI_IO) || (fc == XPT_ATA_IO) || (fc == XPT_SMP_IO)
-	 || (fc == XPT_DEV_MATCH) || (fc == XPT_DEV_ADVINFO)) {
+            || (fc == XPT_DEV_MATCH) || (fc == XPT_DEV_ADVINFO) || (fc == XPT_MMC_IO)) {
 		bzero(&mapinfo, sizeof(mapinfo));
 
 		/*
@@ -2252,6 +2252,5 @@ passerror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 	periph = xpt_path_periph(ccb->ccb_h.path);
 	softc = (struct pass_softc *)periph->softc;
 	
-	return(cam_periph_error(ccb, cam_flags, sense_flags, 
-				 &softc->saved_ccb));
+	return(cam_periph_error(ccb, cam_flags, sense_flags));
 }
diff --git a/sys/cam/scsi/scsi_pt.c b/sys/cam/scsi/scsi_pt.c
index e9d24377c92..b9805595ff4 100644
--- a/sys/cam/scsi/scsi_pt.c
+++ b/sys/cam/scsi/scsi_pt.c
@@ -569,8 +569,7 @@ pterror(union ccb *ccb, u_int32_t cam_flags, u_int32_t sense_flags)
 	periph = xpt_path_periph(ccb->ccb_h.path);
 	softc = (struct pt_softc *)periph->softc;
 
-	return(cam_periph_error(ccb, cam_flags, sense_flags,
-				&softc->saved_ccb));
+	return(cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 static int
diff --git a/sys/cam/scsi/scsi_sa.c b/sys/cam/scsi/scsi_sa.c
index 2ed06abb820..a34d051ad37 100644
--- a/sys/cam/scsi/scsi_sa.c
+++ b/sys/cam/scsi/scsi_sa.c
@@ -68,7 +68,7 @@ __FBSDID("$FreeBSD$");
 
 #ifdef _KERNEL
 
-#include <opt_sa.h>
+#include "opt_sa.h"
 
 #ifndef SA_IO_TIMEOUT
 #define SA_IO_TIMEOUT		32
@@ -3443,7 +3443,7 @@ saerror(union ccb *ccb, u_int32_t cflgs, u_int32_t sflgs)
 		/*
 		 * Otherwise, we let the common code handle this.
 		 */
-		return (cam_periph_error(ccb, cflgs, sflgs, &softc->saved_ccb));
+		return (cam_periph_error(ccb, cflgs, sflgs));
 
 	/*
 	 * XXX: To Be Fixed
@@ -3456,7 +3456,7 @@ saerror(union ccb *ccb, u_int32_t cflgs, u_int32_t sflgs)
 		}
 		/* FALLTHROUGH */
 	default:
-		return (cam_periph_error(ccb, cflgs, sflgs, &softc->saved_ccb));
+		return (cam_periph_error(ccb, cflgs, sflgs));
 	}
 
 	/*
diff --git a/sys/cam/scsi/scsi_sg.c b/sys/cam/scsi/scsi_sg.c
index ef83fc7c3cf..cd81186c801 100644
--- a/sys/cam/scsi/scsi_sg.c
+++ b/sys/cam/scsi/scsi_sg.c
@@ -941,8 +941,7 @@ sgerror(union ccb *ccb, uint32_t cam_flags, uint32_t sense_flags)
 	periph = xpt_path_periph(ccb->ccb_h.path);
 	softc = (struct sg_softc *)periph->softc;
 
-	return (cam_periph_error(ccb, cam_flags, sense_flags,
-				 &softc->saved_ccb));
+	return (cam_periph_error(ccb, cam_flags, sense_flags));
 }
 
 static void
diff --git a/sys/cam/scsi/scsi_xpt.c b/sys/cam/scsi/scsi_xpt.c
index 065d433e5c7..ae8353bcb77 100644
--- a/sys/cam/scsi/scsi_xpt.c
+++ b/sys/cam/scsi/scsi_xpt.c
@@ -1160,8 +1160,8 @@ probedone(struct cam_periph *periph, union ccb *done_ccb)
 	{
 		if (cam_ccb_status(done_ccb) != CAM_REQ_CMP) {
 
-			if (cam_periph_error(done_ccb, 0,
-					     SF_NO_PRINT, NULL) == ERESTART) {
+			if (cam_periph_error(done_ccb, 0, SF_NO_PRINT) ==
+			    ERESTART) {
 outr:
 				/* Drop freeze taken due to CAM_DEV_QFREEZE */
 				cam_release_devq(path, 0, 0, 0, FALSE);
@@ -1258,8 +1258,7 @@ out:
 		} else if (cam_periph_error(done_ccb, 0,
 					    done_ccb->ccb_h.target_lun > 0
 					    ? SF_RETRY_UA|SF_QUIET_IR
-					    : SF_RETRY_UA,
-					    &softc->saved_ccb) == ERESTART) {
+					    : SF_RETRY_UA) == ERESTART) {
 			goto outr;
 		} else {
 			if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
@@ -1302,8 +1301,8 @@ out:
 		if (cam_ccb_status(done_ccb) != CAM_REQ_CMP) {
 			if (cam_periph_error(done_ccb, 0,
 			    done_ccb->ccb_h.target_lun > 0 ?
-			    SF_RETRY_UA|SF_QUIET_IR : SF_RETRY_UA,
-			    &softc->saved_ccb) == ERESTART) {
+			    SF_RETRY_UA|SF_QUIET_IR : SF_RETRY_UA) == 
+				ERESTART) {
 				goto outr;
 			}
 			if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
@@ -1407,8 +1406,7 @@ out:
 			page = (struct scsi_control_page *)offset;
 			path->device->queue_flags = page->queue_flags;
 		} else if (cam_periph_error(done_ccb, 0,
-					    SF_RETRY_UA|SF_NO_PRINT,
-					    &softc->saved_ccb) == ERESTART) {
+			SF_RETRY_UA|SF_NO_PRINT) == ERESTART) {
 			goto outr;
 		} else if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
@@ -1450,8 +1448,7 @@ out:
 			xpt_schedule(periph, priority);
 			goto out;
 		} else if (cam_periph_error(done_ccb, 0,
-					    SF_RETRY_UA|SF_NO_PRINT,
-					    &softc->saved_ccb) == ERESTART) {
+			SF_RETRY_UA|SF_NO_PRINT) == ERESTART) {
 			goto outr;
 		} else if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
@@ -1495,8 +1492,7 @@ out:
 				path->device->device_id = (uint8_t *)devid;
 			}
 		} else if (cam_periph_error(done_ccb, 0,
-					    SF_RETRY_UA,
-					    &softc->saved_ccb) == ERESTART) {
+			SF_RETRY_UA) == ERESTART) {
 			goto outr;
 		} else if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
@@ -1538,9 +1534,8 @@ out:
 				path->device->ext_inq_len = length;
 				path->device->ext_inq = (uint8_t *)ext_inq;
 			}
-		} else if (cam_periph_error(done_ccb, 0,
-					    SF_RETRY_UA,
-					    &softc->saved_ccb) == ERESTART) {
+		} else if (cam_periph_error(done_ccb, 0, SF_RETRY_UA) ==
+		    ERESTART) {
 			goto outr;
 		} else if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
@@ -1603,8 +1598,7 @@ probe_device_check:
 				path->device->serial_num[slen] = '\0';
 			}
 		} else if (cam_periph_error(done_ccb, 0,
-					    SF_RETRY_UA|SF_NO_PRINT,
-					    &softc->saved_ccb) == ERESTART) {
+			SF_RETRY_UA|SF_NO_PRINT) == ERESTART) {
 			goto outr;
 		} else if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
@@ -1673,7 +1667,7 @@ probe_device_check:
 	case PROBE_DV_EXIT:
 		if (cam_ccb_status(done_ccb) != CAM_REQ_CMP) {
 			cam_periph_error(done_ccb, 0,
-			    SF_NO_PRINT | SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+			    SF_NO_PRINT | SF_NO_RECOVERY | SF_NO_RETRY);
 		}
 		if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
@@ -1724,7 +1718,7 @@ probe_device_check:
 
 		if (cam_ccb_status(done_ccb) != CAM_REQ_CMP) {
 			cam_periph_error(done_ccb, 0,
-			    SF_NO_PRINT | SF_NO_RECOVERY | SF_NO_RETRY, NULL);
+			    SF_NO_PRINT | SF_NO_RECOVERY | SF_NO_RETRY);
 		}
 		if ((done_ccb->ccb_h.status & CAM_DEV_QFRZN) != 0) {
 			/* Don't wedge the queue */
diff --git a/sys/conf/files b/sys/conf/files
index a39d9d58810..e75f49144e7 100644
--- a/sys/conf/files
+++ b/sys/conf/files
@@ -110,6 +110,8 @@ cam/ctl/ctl_tpc_local.c		optional ctl
 cam/ctl/ctl_error.c		optional ctl
 cam/ctl/ctl_util.c		optional ctl
 cam/ctl/scsi_ctl.c		optional ctl
+cam/mmc/mmc_xpt.c		optional scbus mmccam
+cam/mmc/mmc_da.c		optional scbus mmccam da
 cam/scsi/scsi_da.c		optional da
 cam/scsi/scsi_low.c		optional ncv | nsp | stg
 cam/scsi/scsi_pass.c		optional pass
@@ -2221,11 +2223,12 @@ dev/mlx/mlx.c			optional mlx
 dev/mlx/mlx_disk.c		optional mlx
 dev/mlx/mlx_pci.c		optional mlx pci
 dev/mly/mly.c			optional mly
-dev/mmc/mmc_subr.c		optional mmc | mmcsd
-dev/mmc/mmc.c			optional mmc
+dev/mmc/mmc_subr.c		optional mmc | mmcsd !mmccam
+dev/mmc/mmc.c			optional mmc !mmccam
 dev/mmc/mmcbr_if.m		standard
 dev/mmc/mmcbus_if.m		standard
-dev/mmc/mmcsd.c			optional mmcsd
+dev/mmc/mmcsd.c			optional mmcsd !mmccam
+dev/mmcnull/mmcnull.c		optional mmcnull
 dev/mn/if_mn.c			optional mn pci
 dev/mpr/mpr.c			optional mpr
 dev/mpr/mpr_config.c		optional mpr
diff --git a/sys/conf/options b/sys/conf/options
index fde61d84d8f..b400b929856 100644
--- a/sys/conf/options
+++ b/sys/conf/options
@@ -997,5 +997,7 @@ UINPUT_DEBUG	opt_evdev.h
 # Hyper-V network driver
 HN_DEBUG	opt_hn.h
 
+# CAM-based MMC stack
+MMCCAM
 # Encrypted kernel crash dumps
 EKCD		opt_ekcd.h
diff --git a/sys/ddb/db_sym.c b/sys/ddb/db_sym.c
index c21445c520b..48d77a09703 100644
--- a/sys/ddb/db_sym.c
+++ b/sys/ddb/db_sym.c
@@ -44,7 +44,7 @@ __FBSDID("$FreeBSD$");
 #include <ddb/db_sym.h>
 #include <ddb/db_variables.h>
 
-#include <opt_ddb.h>
+#include "opt_ddb.h"
 
 /*
  * Multiple symbol tables
diff --git a/sys/dev/aic7xxx/aic79xx_osm.h b/sys/dev/aic7xxx/aic79xx_osm.h
index db790dffd58..dd0764a7751 100644
--- a/sys/dev/aic7xxx/aic79xx_osm.h
+++ b/sys/dev/aic7xxx/aic79xx_osm.h
@@ -38,7 +38,7 @@
 #ifndef _AIC79XX_FREEBSD_H_
 #define _AIC79XX_FREEBSD_H_
 
-#include <opt_aic79xx.h>	/* for config options */
+#include "opt_aic79xx.h"	/* for config options */
 
 #include <sys/param.h>
 #include <sys/systm.h>
diff --git a/sys/dev/aic7xxx/aic7xxx_osm.h b/sys/dev/aic7xxx/aic7xxx_osm.h
index 054811e9d97..601130f71f7 100644
--- a/sys/dev/aic7xxx/aic7xxx_osm.h
+++ b/sys/dev/aic7xxx/aic7xxx_osm.h
@@ -37,7 +37,7 @@
 #ifndef _AIC7XXX_FREEBSD_H_
 #define _AIC7XXX_FREEBSD_H_
 
-#include <opt_aic7xxx.h>	/* for config options */
+#include "opt_aic7xxx.h"	/* for config options */
 
 #include <sys/param.h>
 #include <sys/systm.h>
diff --git a/sys/dev/drm/drmP.h b/sys/dev/drm/drmP.h
index 8c4ece5c19e..67bd3355a61 100644
--- a/sys/dev/drm/drmP.h
+++ b/sys/dev/drm/drmP.h
@@ -103,7 +103,7 @@ struct drm_file;
 #include "dev/drm/drm_internal.h"
 #include "dev/drm/drm_linux_list.h"
 
-#include <opt_drm.h>
+#include "opt_drm.h"
 #ifdef DRM_DEBUG
 #undef DRM_DEBUG
 #define DRM_DEBUG_DEFAULT_ON 1
diff --git a/sys/dev/isci/environment.h b/sys/dev/isci/environment.h
index 5c9374ca871..63bd0e89eee 100644
--- a/sys/dev/isci/environment.h
+++ b/sys/dev/isci/environment.h
@@ -42,7 +42,7 @@
 #include <sys/types.h>
 #include <sys/libkern.h>
 #include <machine/bus.h>
-#include <opt_isci.h>
+#include "opt_isci.h"
 
 typedef int8_t 		S8;
 typedef uint8_t		U8;
diff --git a/sys/dev/mmc/bridge.h b/sys/dev/mmc/bridge.h
index a780ffaeea4..502f433c0d5 100644
--- a/sys/dev/mmc/bridge.h
+++ b/sys/dev/mmc/bridge.h
@@ -174,6 +174,7 @@ struct mmc_host {
 	struct mmc_ios ios;	/* Current state of the host */
 };
 
+#ifdef _KERNEL
 extern driver_t   mmc_driver;
 extern devclass_t mmc_devclass;
 
@@ -184,5 +185,6 @@ extern devclass_t mmc_devclass;
     MODULE_DEPEND(name, mmc, MMC_VERSION, MMC_VERSION, MMC_VERSION);
 #define	MMC_DEPEND(name)						\
     MODULE_DEPEND(name, mmc, MMC_VERSION, MMC_VERSION, MMC_VERSION);
+#endif /* _KERNEL */
 
 #endif /* DEV_MMC_BRIDGE_H */
diff --git a/sys/dev/mmc/host/dwmmc.c b/sys/dev/mmc/host/dwmmc.c
index 18b6dee4dad..cb374a0e240 100644
--- a/sys/dev/mmc/host/dwmmc.c
+++ b/sys/dev/mmc/host/dwmmc.c
@@ -59,6 +59,8 @@ __FBSDID("$FreeBSD$");
 #include <dev/mmc/host/dwmmc_reg.h>
 #include <dev/mmc/host/dwmmc_var.h>
 
+#include "opt_mmccam.h"
+
 #include "mmcbr_if.h"
 
 #define dprintf(x, arg...)
@@ -1181,4 +1183,6 @@ static devclass_t dwmmc_devclass;
 
 DRIVER_MODULE(dwmmc, simplebus, dwmmc_driver, dwmmc_devclass, NULL, NULL);
 DRIVER_MODULE(dwmmc, ofwbus, dwmmc_driver, dwmmc_devclass, NULL, NULL);
+#ifndef MMCCAM
 MMC_DECLARE_BRIDGE(dwmmc);
+#endif
diff --git a/sys/dev/mmc/host/dwmmc_altera.c b/sys/dev/mmc/host/dwmmc_altera.c
new file mode 100644
index 00000000000..5d2baf6c412
--- /dev/null
+++ b/sys/dev/mmc/host/dwmmc_altera.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2017 Emmanuel Vadot <manu@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/bus.h>
+#include <sys/module.h>
+
+#include <machine/bus.h>
+
+#include <dev/mmc/bridge.h>
+
+#include <dev/ofw/ofw_bus_subr.h>
+
+#include <dev/mmc/host/dwmmc_var.h>
+
+static struct ofw_compat_data compat_data[] = {
+	{"altr,socfpga-dw-mshc",	1},
+	{NULL,				0},
+};
+
+static int
+altera_dwmmc_probe(device_t dev)
+{
+
+	if (!ofw_bus_status_okay(dev))
+		return (ENXIO);
+
+	if (ofw_bus_search_compatible(dev, compat_data)->ocd_data == 0)
+		return (ENXIO);
+
+	device_set_desc(dev, "Synopsys DesignWare Mobile "
+	    "Storage Host Controller (Altera)");
+
+	return (BUS_PROBE_VENDOR);
+}
+
+static int
+altera_dwmmc_attach(device_t dev)
+{
+	struct dwmmc_softc *sc;
+
+	sc = device_get_softc(dev);
+	sc->hwtype = HWTYPE_ALTERA;
+
+	return (dwmmc_attach(dev));
+}
+
+static device_method_t altera_dwmmc_methods[] = {
+	/* bus interface */
+	DEVMETHOD(device_probe, altera_dwmmc_probe),
+	DEVMETHOD(device_attach, altera_dwmmc_attach),
+
+	DEVMETHOD_END
+};
+
+static devclass_t altera_dwmmc_devclass;
+
+DEFINE_CLASS_1(altera_dwmmc, altera_dwmmc_driver, altera_dwmmc_methods,
+    sizeof(struct dwmmc_softc), dwmmc_driver);
+
+DRIVER_MODULE(altera_dwmmc, simplebus, altera_dwmmc_driver,
+    altera_dwmmc_devclass, 0, 0);
+DRIVER_MODULE(altera_dwmmc, ofwbus, altera_dwmmc_driver, altera_dwmmc_devclass
+    , NULL, NULL);
+#ifndef MMCCAM
+MMC_DECLARE_BRIDGE(altera_dwmmc);
+#endif
diff --git a/sys/dev/mmc/host/dwmmc_rockchip.c b/sys/dev/mmc/host/dwmmc_rockchip.c
new file mode 100644
index 00000000000..7a85e2d1f1d
--- /dev/null
+++ b/sys/dev/mmc/host/dwmmc_rockchip.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2017 Emmanuel Vadot <manu@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/bus.h>
+#include <sys/module.h>
+
+#include <machine/bus.h>
+
+#include <dev/mmc/bridge.h>
+
+#include <dev/ofw/ofw_bus_subr.h>
+
+#ifdef EXT_RESOURCES
+#include <dev/extres/clk/clk.h>
+#endif
+
+#include <dev/mmc/host/dwmmc_var.h>
+
+#include "opt_mmccam.h"
+
+enum RKTYPE {
+	RK2928 = 1,
+	RK3328,
+};
+
+static struct ofw_compat_data compat_data[] = {
+	{"rockchip,rk2928-dw-mshc",	RK2928},
+	{"rockchip,rk3328-dw-mshc",	RK3328},
+	{NULL,				0},
+};
+
+static int dwmmc_rockchip_update_ios(struct dwmmc_softc *sc, struct mmc_ios *ios);
+
+static int
+rockchip_dwmmc_probe(device_t dev)
+{
+
+	if (!ofw_bus_status_okay(dev))
+		return (ENXIO);
+
+	if (ofw_bus_search_compatible(dev, compat_data)->ocd_data == 0)
+		return (ENXIO);
+
+	device_set_desc(dev, "Synopsys DesignWare Mobile "
+	    "Storage Host Controller (RockChip)");
+
+	return (BUS_PROBE_VENDOR);
+}
+
+static int
+rockchip_dwmmc_attach(device_t dev)
+{
+	struct dwmmc_softc *sc;
+	int type;
+
+	sc = device_get_softc(dev);
+	sc->hwtype = HWTYPE_ROCKCHIP;
+	type = ofw_bus_search_compatible(dev, compat_data)->ocd_data;
+
+	switch (type) {
+	case RK2928:
+		sc->use_pio = 1;
+		break;
+	}
+
+	sc->pwren_inverted = 1;
+
+#ifdef EXT_RESOURCES
+	sc->update_ios = &dwmmc_rockchip_update_ios;
+#endif
+
+	return (dwmmc_attach(dev));
+}
+
+#ifdef EXT_RESOURCES
+static int
+dwmmc_rockchip_update_ios(struct dwmmc_softc *sc, struct mmc_ios *ios)
+{
+	unsigned int clock;
+	int error;
+
+	if (ios->clock && ios->clock != sc->bus_hz) {
+		sc->bus_hz = clock = ios->clock;
+		/* Set the MMC clock. */
+		if (sc->ciu) {
+			/* 
+			 * Apparently you need to set the ciu clock to
+			 * the double of bus_hz
+			 */
+			error = clk_set_freq(sc->ciu, clock * 2,
+			    CLK_SET_ROUND_DOWN);
+			if (error != 0) {
+				device_printf(sc->dev,
+				    "failed to set frequency to %u Hz: %d\n",
+				    clock, error);
+				return (error);
+			}
+		}
+	}
+	return (0);
+}
+#endif
+
+static device_method_t rockchip_dwmmc_methods[] = {
+	/* bus interface */
+	DEVMETHOD(device_probe, rockchip_dwmmc_probe),
+	DEVMETHOD(device_attach, rockchip_dwmmc_attach),
+
+	DEVMETHOD_END
+};
+
+static devclass_t rockchip_dwmmc_devclass;
+
+DEFINE_CLASS_1(rockchip_dwmmc, rockchip_dwmmc_driver, rockchip_dwmmc_methods,
+    sizeof(struct dwmmc_softc), dwmmc_driver);
+
+DRIVER_MODULE(rockchip_dwmmc, simplebus, rockchip_dwmmc_driver,
+    rockchip_dwmmc_devclass, 0, 0);
+DRIVER_MODULE(rockchip_dwmmc, ofwbus, rockchip_dwmmc_driver,
+    rockchip_dwmmc_devclass, NULL, NULL);
+#ifndef MMCCAM
+MMC_DECLARE_BRIDGE(rockchip_dwmmc);
+#endif
diff --git a/sys/dev/mmc/host/dwmmc_samsung.c b/sys/dev/mmc/host/dwmmc_samsung.c
new file mode 100644
index 00000000000..0a6efe7b2e0
--- /dev/null
+++ b/sys/dev/mmc/host/dwmmc_samsung.c
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2017 Emmanuel Vadot <manu@freebsd.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/kernel.h>
+#include <sys/bus.h>
+#include <sys/module.h>
+
+#include <machine/bus.h>
+
+#include <dev/mmc/bridge.h>
+
+#include <dev/ofw/ofw_bus.h>
+#include <dev/ofw/ofw_bus_subr.h>
+
+#include <dev/mmc/host/dwmmc_var.h>
+#include <dev/mmc/host/dwmmc_reg.h>
+
+#define	WRITE4(_sc, _reg, _val)		\
+	bus_write_4((_sc)->res[0], _reg, _val)
+
+static struct ofw_compat_data compat_data[] = {
+	{"samsung,exynos5420-dw-mshc",	1},
+	{NULL,				0},
+};
+
+static int
+samsung_dwmmc_probe(device_t dev)
+{
+
+	if (!ofw_bus_status_okay(dev))
+		return (ENXIO);
+
+	if (ofw_bus_search_compatible(dev, compat_data)->ocd_data == 0)
+		return (ENXIO);
+
+	device_set_desc(dev, "Synopsys DesignWare Mobile "
+	    "Storage Host Controller (Samsung)");
+
+	return (BUS_PROBE_VENDOR);
+}
+
+static int
+samsung_dwmmc_attach(device_t dev)
+{
+	struct dwmmc_softc *sc;
+	pcell_t dts_value[3];
+	phandle_t node;
+	int len;
+
+	sc = device_get_softc(dev);
+	sc->hwtype = HWTYPE_EXYNOS;
+
+	if ((node = ofw_bus_get_node(sc->dev)) == -1)
+		return (ENXIO);
+
+	if ((len = OF_getproplen(node, "samsung,dw-mshc-ciu-div")) <= 0)
+		return (ENXIO);
+	OF_getencprop(node, "samsung,dw-mshc-ciu-div", dts_value, len);
+	sc->sdr_timing = (dts_value[0] << SDMMC_CLKSEL_DIVIDER_SHIFT);
+	sc->ddr_timing = (dts_value[0] << SDMMC_CLKSEL_DIVIDER_SHIFT);
+
+	if ((len = OF_getproplen(node, "samsung,dw-mshc-sdr-timing")) <= 0)
+		return (ENXIO);
+	OF_getencprop(node, "samsung,dw-mshc-sdr-timing", dts_value, len);
+	sc->sdr_timing |= ((dts_value[0] << SDMMC_CLKSEL_SAMPLE_SHIFT) |
+			  (dts_value[1] << SDMMC_CLKSEL_DRIVE_SHIFT));
+
+	if ((len = OF_getproplen(node, "samsung,dw-mshc-ddr-timing")) <= 0)
+		return (ENXIO);
+	OF_getencprop(node, "samsung,dw-mshc-ddr-timing", dts_value, len);
+	sc->ddr_timing |= ((dts_value[0] << SDMMC_CLKSEL_SAMPLE_SHIFT) |
+			  (dts_value[1] << SDMMC_CLKSEL_DRIVE_SHIFT));
+
+	WRITE4(sc, EMMCP_MPSBEGIN0, 0);
+	WRITE4(sc, EMMCP_SEND0, 0);
+	WRITE4(sc, EMMCP_CTRL0, (MPSCTRL_SECURE_READ_BIT |
+	    MPSCTRL_SECURE_WRITE_BIT |
+	    MPSCTRL_NON_SECURE_READ_BIT |
+	    MPSCTRL_NON_SECURE_WRITE_BIT |
+	    MPSCTRL_VALID));
+
+	return (dwmmc_attach(dev));
+}
+
+static device_method_t samsung_dwmmc_methods[] = {
+	/* bus interface */
+	DEVMETHOD(device_probe, samsung_dwmmc_probe),
+	DEVMETHOD(device_attach, samsung_dwmmc_attach),
+
+	DEVMETHOD_END
+};
+
+static devclass_t samsung_dwmmc_devclass;
+
+DEFINE_CLASS_1(samsung_dwmmc, samsung_dwmmc_driver, samsung_dwmmc_methods,
+    sizeof(struct dwmmc_softc), dwmmc_driver);
+
+DRIVER_MODULE(samsung_dwmmc, simplebus, samsung_dwmmc_driver,
+    samsung_dwmmc_devclass, 0, 0);
+DRIVER_MODULE(samsung_dwmmc, ofwbus, samsung_dwmmc_driver, samsung_dwmmc_devclass
+    , NULL, NULL);
+#ifndef MMCCAM
+MMC_DECLARE_BRIDGE(samsung_dwmmc);
+#endif
diff --git a/sys/dev/mmc/mmcbrvar.h b/sys/dev/mmc/mmcbrvar.h
index d8f79156b81..47024da7696 100644
--- a/sys/dev/mmc/mmcbrvar.h
+++ b/sys/dev/mmc/mmcbrvar.h
@@ -56,7 +56,6 @@
 #define	DEV_MMC_MMCBRVAR_H
 
 #include <dev/mmc/mmcreg.h>
-
 #include "mmcbr_if.h"
 
 enum mmcbr_device_ivars {
diff --git a/sys/dev/mmc/mmcreg.h b/sys/dev/mmc/mmcreg.h
index 359f31d50c7..671b8c23529 100644
--- a/sys/dev/mmc/mmcreg.h
+++ b/sys/dev/mmc/mmcreg.h
@@ -1,6 +1,7 @@
 /*-
  * Copyright (c) 2006 M. Warner Losh.  All rights reserved.
  * Copyright (c) 2017 Marius Strobl <marius@FreeBSD.org>
+ * Copyright (c) 2015-2016 Ilya Bakulin <kibab@FreeBSD.org>
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -156,6 +157,34 @@ struct mmc_command {
 #define	R1_STATE_PRG	7
 #define	R1_STATE_DIS	8
 
+/* R4 response (SDIO) */
+#define R4_IO_NUM_FUNCTIONS(ocr)	(((ocr) >> 28) & 0x3)
+#define R4_IO_MEM_PRESENT		(0x1<<27)
+#define R4_IO_OCR_MASK			0x00fffff0
+
+/*
+ * R5 responses
+ *
+ * Types (per SD 2.0 standard)
+ *e : error bit
+ *s : status bit
+ *r : detected and set for the actual command response
+ *x : Detected and set during command execution.  The host can get
+ *    the status by issuing a command with R1 response.
+ *
+ * Clear Condition (per SD 2.0 standard)
+ *a : according to the card current state.
+ *b : always related to the previous command.  reception of a valid
+ *    command will clear it (with a delay of one command).
+ *c : clear by read
+ */
+#define R5_COM_CRC_ERROR		(1u << 15)/* er, b */
+#define R5_ILLEGAL_COMMAND		(1u << 14)/* er, b */
+#define R5_IO_CURRENT_STATE_MASK	(3u << 12)/* s, b */
+#define R5_IO_CURRENT_STATE(x) 		(((x) & R5_IO_CURRENT_STATE_MASK) >> 12)
+#define R5_ERROR			(1u << 11)/* erx, c */
+#define R5_FUNCTION_NUMBER		(1u << 9)/* er, c */
+#define R5_OUT_OF_RANGE			(1u << 8)/* er, c */
 struct mmc_data {
 	size_t len;		/* size of the data */
 	size_t xfer_len;
@@ -187,6 +216,7 @@ struct mmc_request {
 #define	SD_SEND_RELATIVE_ADDR	3
 #define	MMC_SET_DSR		4
 #define	MMC_SLEEP_AWAKE		5
+#define IO_SEND_OP_COND		5
 #define	MMC_SWITCH_FUNC		6
 #define	 MMC_SWITCH_FUNC_CMDS	 0
 #define	 MMC_SWITCH_FUNC_SET	 1
@@ -269,7 +299,31 @@ struct mmc_request {
 
 /* Class 9: I/O cards (sd) */
 #define	SD_IO_RW_DIRECT		52
+/* CMD52 arguments */
+#define  SD_ARG_CMD52_READ		(0<<31)
+#define  SD_ARG_CMD52_WRITE		(1<<31)
+#define  SD_ARG_CMD52_FUNC_SHIFT		28
+#define  SD_ARG_CMD52_FUNC_MASK		0x7
+#define  SD_ARG_CMD52_EXCHANGE		(1<<27)
+#define  SD_ARG_CMD52_REG_SHIFT		9
+#define  SD_ARG_CMD52_REG_MASK		0x1ffff
+#define  SD_ARG_CMD52_DATA_SHIFT		0
+#define  SD_ARG_CMD52_DATA_MASK		0xff
+#define  SD_R5_DATA(resp)		((resp)[0] & 0xff)
+
 #define	SD_IO_RW_EXTENDED	53
+/* CMD53 arguments */
+#define  SD_ARG_CMD53_READ		(0<<31)
+#define  SD_ARG_CMD53_WRITE		(1<<31)
+#define  SD_ARG_CMD53_FUNC_SHIFT		28
+#define  SD_ARG_CMD53_FUNC_MASK		0x7
+#define  SD_ARG_CMD53_BLOCK_MODE		(1<<27)
+#define  SD_ARG_CMD53_INCREMENT		(1<<26)
+#define  SD_ARG_CMD53_REG_SHIFT		9
+#define  SD_ARG_CMD53_REG_MASK		0x1ffff
+#define  SD_ARG_CMD53_LENGTH_SHIFT	0
+#define  SD_ARG_CMD53_LENGTH_MASK	0x1ff
+#define  SD_ARG_CMD53_LENGTH_MAX		64 /* XXX should be 511? */
 
 /* Class 10: Switch function commands */
 #define	SD_SWITCH_FUNC		6
@@ -440,6 +494,54 @@ struct mmc_request {
 /* Specifications require 400 kHz max. during ID phase. */
 #define	SD_MMC_CARD_ID_FREQUENCY	400000
 
+/*
+ * SDIO Direct & Extended I/O
+ */
+#define SD_IO_RW_WR		(1u << 31)
+#define SD_IO_RW_FUNC(x)	(((x) & 0x7) << 28)
+#define SD_IO_RW_RAW		(1u << 27)
+#define SD_IO_RW_INCR		(1u << 26)
+#define SD_IO_RW_ADR(x)		(((x) & 0x1FFFF) << 9)
+#define SD_IO_RW_DAT(x)		(((x) & 0xFF) << 0)
+#define SD_IO_RW_LEN(x)		(((x) & 0xFF) << 0)
+
+#define SD_IOE_RW_LEN(x)	(((x) & 0x1FF) << 0)
+#define SD_IOE_RW_BLK		(1u << 27)
+
+/* Card Common Control Registers (CCCR) */
+#define SD_IO_CCCR_START		0x00000
+#define SD_IO_CCCR_SIZE			0x100
+#define SD_IO_CCCR_FN_ENABLE		0x02
+#define SD_IO_CCCR_FN_READY		0x03
+#define SD_IO_CCCR_INT_ENABLE		0x04
+#define SD_IO_CCCR_INT_PENDING		0x05
+#define SD_IO_CCCR_CTL			0x06
+#define  CCCR_CTL_RES			(1<<3)
+#define SD_IO_CCCR_BUS_WIDTH		0x07
+#define  CCCR_BUS_WIDTH_4		(1<<1)
+#define  CCCR_BUS_WIDTH_1		(1<<0)
+#define SD_IO_CCCR_CARDCAP		0x08
+#define SD_IO_CCCR_CISPTR		0x09 /* XXX 9-10, 10-11, or 9-12 */
+
+/* Function Basic Registers (FBR) */
+#define SD_IO_FBR_START			0x00100
+#define SD_IO_FBR_SIZE			0x00700
+
+/* Card Information Structure (CIS) */
+#define SD_IO_CIS_START			0x01000
+#define SD_IO_CIS_SIZE			0x17000
+
+/* CIS tuple codes (based on PC Card 16) */
+#define SD_IO_CISTPL_VERS_1		0x15
+#define SD_IO_CISTPL_MANFID		0x20
+#define SD_IO_CISTPL_FUNCID		0x21
+#define SD_IO_CISTPL_FUNCE		0x22
+#define SD_IO_CISTPL_END		0xff
+
+/* CISTPL_FUNCID codes */
+/* OpenBSD incorrectly defines 0x0c as FUNCTION_WLAN */
+/* #define SDMMC_FUNCTION_WLAN		0x0c */
+
 /* OCR bits */
 
 /*
diff --git a/sys/dev/sdhci/fsl_sdhci.c b/sys/dev/sdhci/fsl_sdhci.c
index 1b5f9371fb5..633f39a0246 100644
--- a/sys/dev/sdhci/fsl_sdhci.c
+++ b/sys/dev/sdhci/fsl_sdhci.c
@@ -33,6 +33,8 @@ __FBSDID("$FreeBSD$");
  * This supports both eSDHC (earlier SoCs) and uSDHC (more recent SoCs).
  */
 
+#include "opt_mmccam.h"
+
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/types.h>
@@ -988,4 +990,7 @@ static driver_t fsl_sdhci_driver = {
 DRIVER_MODULE(sdhci_fsl, simplebus, fsl_sdhci_driver, fsl_sdhci_devclass,
     NULL, NULL);
 MODULE_DEPEND(sdhci_fsl, sdhci, 1, 1, 1);
+
+#ifndef MMCCAM
 MMC_DECLARE_BRIDGE(sdhci_fsl);
+#endif
diff --git a/sys/dev/sdhci/sdhci.c b/sys/dev/sdhci/sdhci.c
index 26602ec57b4..de4d247fdbf 100644
--- a/sys/dev/sdhci/sdhci.c
+++ b/sys/dev/sdhci/sdhci.c
@@ -48,13 +48,21 @@ __FBSDID("$FreeBSD$");
 #include <dev/mmc/mmcreg.h>
 #include <dev/mmc/mmcbrvar.h>
 
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <cam/cam_debug.h>
+#include <cam/cam_sim.h>
+#include <cam/cam_xpt_sim.h>
+
 #include "mmcbr_if.h"
 #include "sdhci.h"
 #include "sdhci_if.h"
 
+#include "opt_mmccam.h"
+
 SYSCTL_NODE(_hw, OID_AUTO, sdhci, CTLFLAG_RD, 0, "sdhci driver");
 
-static int sdhci_debug;
+static int sdhci_debug = 0;
 SYSCTL_INT(_hw_sdhci, OID_AUTO, debug, CTLFLAG_RWTUN, &sdhci_debug, 0,
     "Debug level");
 u_int sdhci_quirk_clear = 0;
@@ -83,6 +91,16 @@ static void sdhci_start_data(struct sdhci_slot *slot, struct mmc_data *data);
 static void sdhci_card_poll(void *);
 static void sdhci_card_task(void *, int);
 
+#ifdef MMCCAM
+/* CAM-related */
+int sdhci_cam_get_possible_host_clock(struct sdhci_slot *slot, int proposed_clock);
+static int sdhci_cam_update_ios(struct sdhci_slot *slot);
+static int sdhci_cam_request(struct sdhci_slot *slot, union ccb *ccb);
+static void sdhci_cam_action(struct cam_sim *sim, union ccb *ccb);
+static void sdhci_cam_poll(struct cam_sim *sim);
+static int sdhci_cam_settran_settings(struct sdhci_slot *slot, union ccb *ccb);
+#endif
+
 /* helper routines */
 static void sdhci_dumpregs(struct sdhci_slot *slot);
 static int slot_printf(struct sdhci_slot *slot, const char * fmt, ...)
@@ -252,7 +270,7 @@ sdhci_init(struct sdhci_slot *slot)
 	    SDHCI_INT_END_BIT | SDHCI_INT_CRC | SDHCI_INT_TIMEOUT |
 	    SDHCI_INT_DATA_AVAIL | SDHCI_INT_SPACE_AVAIL |
 	    SDHCI_INT_DMA_END | SDHCI_INT_DATA_END | SDHCI_INT_RESPONSE |
-	    SDHCI_INT_ACMD12ERR;
+	    SDHCI_INT_ACMD12ERR | SDHCI_INT_CARD_INT;
 
 	if (!(slot->quirks & SDHCI_QUIRK_POLL_CARD_PRESENT) &&
 	    !(slot->opt & SDHCI_NON_REMOVABLE)) {
@@ -366,6 +384,7 @@ sdhci_set_clock(struct sdhci_slot *slot, uint32_t clock)
 static void
 sdhci_set_power(struct sdhci_slot *slot, u_char power)
 {
+	int i;
 	uint8_t pwr;
 
 	if (slot->power == power)
@@ -394,9 +413,20 @@ sdhci_set_power(struct sdhci_slot *slot, u_char power)
 		break;
 	}
 	WR1(slot, SDHCI_POWER_CONTROL, pwr);
-	/* Turn on the power. */
+	/*
+	 * Turn on VDD1 power.  Note that at least some Intel controllers can
+	 * fail to enable bus power on the first try after transiting from D3
+	 * to D0, so we give them up to 2 ms.
+	 */
 	pwr |= SDHCI_POWER_ON;
-	WR1(slot, SDHCI_POWER_CONTROL, pwr);
+	for (i = 0; i < 20; i++) {
+		WR1(slot, SDHCI_POWER_CONTROL, pwr);
+		if (RD1(slot, SDHCI_POWER_CONTROL) & SDHCI_POWER_ON)
+			break;
+		DELAY(100);
+	}
+	if (!(RD1(slot, SDHCI_POWER_CONTROL) & SDHCI_POWER_ON))
+		slot_printf(slot, "Bus power failed to enable");
 
 	if (slot->quirks & SDHCI_QUIRK_INTEL_POWER_UP_RESET) {
 		WR1(slot, SDHCI_POWER_CONTROL, pwr | 0x10);
@@ -519,25 +549,87 @@ sdhci_card_task(void *arg, int pending __unused)
 
 	SDHCI_LOCK(slot);
 	if (SDHCI_GET_CARD_PRESENT(slot->bus, slot)) {
+#ifdef MMCCAM
+		if (slot->card_present == 0) {
+#else
 		if (slot->dev == NULL) {
+#endif
 			/* If card is present - attach mmc bus. */
 			if (bootverbose || sdhci_debug)
 				slot_printf(slot, "Card inserted\n");
+#ifdef MMCCAM
+			slot->card_present = 1;
+			union ccb *ccb;
+			uint32_t pathid;
+			pathid = cam_sim_path(slot->sim);
+			ccb = xpt_alloc_ccb_nowait();
+			if (ccb == NULL) {
+				slot_printf(slot, "Unable to alloc CCB for rescan\n");
+				SDHCI_UNLOCK(slot);
+				return;
+			}
+
+			/*
+			 * We create a rescan request for BUS:0:0, since the card
+			 * will be at lun 0.
+			 */
+			if (xpt_create_path(&ccb->ccb_h.path, NULL, pathid,
+					    /* target */ 0, /* lun */ 0) != CAM_REQ_CMP) {
+				slot_printf(slot, "Unable to create path for rescan\n");
+				SDHCI_UNLOCK(slot);
+				xpt_free_ccb(ccb);
+				return;
+			}
+			SDHCI_UNLOCK(slot);
+			xpt_rescan(ccb);
+#else
 			slot->dev = device_add_child(slot->bus, "mmc", -1);
 			device_set_ivars(slot->dev, slot);
 			SDHCI_UNLOCK(slot);
 			device_probe_and_attach(slot->dev);
+#endif
 		} else
 			SDHCI_UNLOCK(slot);
 	} else {
+#ifdef MMCCAM
+		if (slot->card_present == 1) {
+#else
 		if (slot->dev != NULL) {
+#endif
 			/* If no card present - detach mmc bus. */
 			if (bootverbose || sdhci_debug)
 				slot_printf(slot, "Card removed\n");
 			d = slot->dev;
 			slot->dev = NULL;
+#ifdef MMCCAM
+			slot->card_present = 0;
+			union ccb *ccb;
+			uint32_t pathid;
+			pathid = cam_sim_path(slot->sim);
+			ccb = xpt_alloc_ccb_nowait();
+			if (ccb == NULL) {
+				slot_printf(slot, "Unable to alloc CCB for rescan\n");
+				SDHCI_UNLOCK(slot);
+				return;
+			}
+
+			/*
+			 * We create a rescan request for BUS:0:0, since the card
+			 * will be at lun 0.
+			 */
+			if (xpt_create_path(&ccb->ccb_h.path, NULL, pathid,
+					    /* target */ 0, /* lun */ 0) != CAM_REQ_CMP) {
+				slot_printf(slot, "Unable to create path for rescan\n");
+				SDHCI_UNLOCK(slot);
+				xpt_free_ccb(ccb);
+				return;
+			}
+			SDHCI_UNLOCK(slot);
+			xpt_rescan(ccb);
+#else
 			SDHCI_UNLOCK(slot);
 			device_delete_child(slot->bus, d);
+#endif
 		} else
 			SDHCI_UNLOCK(slot);
 	}
@@ -559,7 +651,11 @@ sdhci_handle_card_present_locked(struct sdhci_slot *slot, bool is_present)
 	 * because once power is removed, a full card re-init is needed, and
 	 * that happens by deleting and recreating the child device.
 	 */
+#ifdef MMCCAM
+	was_present = slot->card_present;
+#else
 	was_present = slot->dev != NULL;
+#endif
 	if (!was_present && is_present) {
 		taskqueue_enqueue_timeout(taskqueue_swi_giant,
 		    &slot->card_delayed_task, -SDHCI_INSERT_DELAY_TICKS);
@@ -595,6 +691,7 @@ sdhci_init_slot(device_t dev, struct sdhci_slot *slot, int num)
 	int err;
 
 	SDHCI_LOCK_INIT(slot);
+
 	slot->num = num;
 	slot->bus = dev;
 
@@ -731,11 +828,11 @@ sdhci_init_slot(device_t dev, struct sdhci_slot *slot, int num)
 	    MMC_CAP_MMC_DDR52_180 | MMC_CAP_MMC_HS200_180 |
 	    MMC_CAP_MMC_HS400_180))
 		host_caps |= MMC_CAP_SIGNALING_180;
-	if (caps & SDHCI_CTRL2_DRIVER_TYPE_A)
+	if (caps2 & SDHCI_CAN_DRIVE_TYPE_A)
 		host_caps |= MMC_CAP_DRIVER_TYPE_A;
-	if (caps & SDHCI_CTRL2_DRIVER_TYPE_C)
+	if (caps2 & SDHCI_CAN_DRIVE_TYPE_C)
 		host_caps |= MMC_CAP_DRIVER_TYPE_C;
-	if (caps & SDHCI_CTRL2_DRIVER_TYPE_D)
+	if (caps2 & SDHCI_CAN_DRIVE_TYPE_D)
 		host_caps |= MMC_CAP_DRIVER_TYPE_D;
 	slot->host.caps = host_caps;
 
@@ -769,9 +866,9 @@ sdhci_init_slot(device_t dev, struct sdhci_slot *slot, int num)
 		    (caps & SDHCI_CAN_VDD_180) ? " 1.8V" : "",
 		    (host_caps & MMC_CAP_SIGNALING_180) ? " 1.8V" : "",
 		    (host_caps & MMC_CAP_SIGNALING_120) ? " 1.2V" : "",
-		    (caps & SDHCI_CTRL2_DRIVER_TYPE_A) ? "A" : "",
-		    (caps & SDHCI_CTRL2_DRIVER_TYPE_C) ? "C" : "",
-		    (caps & SDHCI_CTRL2_DRIVER_TYPE_D) ? "D" : "",
+		    (caps2 & SDHCI_CAN_DRIVE_TYPE_A) ? "A" : "",
+		    (caps2 & SDHCI_CAN_DRIVE_TYPE_C) ? "C" : "",
+		    (caps2 & SDHCI_CAN_DRIVE_TYPE_D) ? "D" : "",
 		    (slot->opt & SDHCI_HAVE_DMA) ? "DMA" : "PIO");
 		if (host_caps & (MMC_CAP_MMC_DDR52 | MMC_CAP_MMC_HS200 |
 		    MMC_CAP_MMC_HS400 | MMC_CAP_MMC_ENH_STROBE))
@@ -814,12 +911,14 @@ sdhci_init_slot(device_t dev, struct sdhci_slot *slot, int num)
 	return (0);
 }
 
+#ifndef MMCCAM
 void
 sdhci_start_slot(struct sdhci_slot *slot)
 {
 
 	sdhci_card_task(slot, 0);
 }
+#endif
 
 int
 sdhci_cleanup_slot(struct sdhci_slot *slot)
@@ -1017,8 +1116,32 @@ done:
 	return (err);
 }
 
+#ifdef MMCCAM
 static void
 sdhci_req_done(struct sdhci_slot *slot)
+{
+        union ccb *ccb;
+
+	if (sdhci_debug > 1)
+		slot_printf(slot, "%s\n", __func__);
+	if (slot->ccb != NULL && slot->curcmd != NULL) {
+		callout_stop(&slot->timeout_callout);
+                ccb = slot->ccb;
+                slot->ccb = NULL;
+		slot->curcmd = NULL;
+
+                /* Tell CAM the request is finished */
+                struct ccb_mmcio *mmcio;
+                mmcio = &ccb->mmcio;
+
+                ccb->ccb_h.status =
+                        (mmcio->cmd.error == 0 ? CAM_REQ_CMP : CAM_REQ_CMP_ERR);
+                xpt_done(ccb);
+	}
+}
+#else
+static void 
+sdhci_req_done(struct sdhci_slot *slot)
 {
 	struct mmc_request *req;
 
@@ -1030,6 +1153,7 @@ sdhci_req_done(struct sdhci_slot *slot)
 		req->done(req);
 	}
 }
+#endif
 
 static void
 sdhci_timeout(void *arg)
@@ -1060,8 +1184,16 @@ sdhci_set_transfer_mode(struct sdhci_slot *slot, struct mmc_data *data)
 		mode |= SDHCI_TRNS_MULTI;
 	if (data->flags & MMC_DATA_READ)
 		mode |= SDHCI_TRNS_READ;
-	if (slot->req->stop)
+#ifdef MMCCAM
+	struct ccb_mmcio *mmcio;
+	mmcio = &slot->ccb->mmcio;
+	if (mmcio->stop.opcode == MMC_STOP_TRANSMISSION
+	    && !(slot->quirks & SDHCI_QUIRK_BROKEN_AUTO_STOP))
 		mode |= SDHCI_TRNS_ACMD12;
+#else
+	if (slot->req->stop && !(slot->quirks & SDHCI_QUIRK_BROKEN_AUTO_STOP))
+		mode |= SDHCI_TRNS_ACMD12;
+#endif
 	if (slot->flags & SDHCI_USE_DMA)
 		mode |= SDHCI_TRNS_DMA;
 
@@ -1094,6 +1226,9 @@ sdhci_start_command(struct sdhci_slot *slot, struct mmc_command *cmd)
 	if (!SDHCI_GET_CARD_PRESENT(slot->bus, slot) ||
 	    slot->power == 0 ||
 	    slot->clock == 0) {
+		slot_printf(slot,
+			    "Cannot issue a command (power=%d clock=%d)",
+			    slot->power, slot->clock);
 		cmd->error = MMC_ERR_FAILED;
 		sdhci_req_done(slot);
 		return;
@@ -1101,11 +1236,17 @@ sdhci_start_command(struct sdhci_slot *slot, struct mmc_command *cmd)
 	/* Always wait for free CMD bus. */
 	mask = SDHCI_CMD_INHIBIT;
 	/* Wait for free DAT if we have data or busy signal. */
-	if (cmd->data || (cmd->flags & MMC_RSP_BUSY))
+	if (cmd->data != NULL || (cmd->flags & MMC_RSP_BUSY))
 		mask |= SDHCI_DAT_INHIBIT;
 	/* We shouldn't wait for DAT for stop commands. */
+#ifdef MMCCAM
+	struct ccb_mmcio *mmcio = &slot->ccb->mmcio;
+	if (cmd == &mmcio->stop)
+		mask &= ~SDHCI_DAT_INHIBIT;
+#else
 	if (cmd == slot->req->stop)
 		mask &= ~SDHCI_DAT_INHIBIT;
+#endif
 	/*
 	 *  Wait for bus no more then 250 ms.  Typically there will be no wait
 	 *  here at all, but when writing a crash dump we may be bypassing the
@@ -1143,7 +1284,7 @@ sdhci_start_command(struct sdhci_slot *slot, struct mmc_command *cmd)
 		flags |= SDHCI_CMD_CRC;
 	if (cmd->flags & MMC_RSP_OPCODE)
 		flags |= SDHCI_CMD_INDEX;
-	if (cmd->data)
+	if (cmd->data != NULL)
 		flags |= SDHCI_CMD_DATA;
 	if (cmd->opcode == MMC_STOP_TRANSMISSION)
 		flags |= SDHCI_CMD_TYPE_ABORT;
@@ -1162,6 +1303,8 @@ sdhci_start_command(struct sdhci_slot *slot, struct mmc_command *cmd)
 	WR4(slot, SDHCI_ARGUMENT, cmd->arg);
 	/* Set data transfer mode. */
 	sdhci_set_transfer_mode(slot, cmd->data);
+	if (sdhci_debug > 1)
+		slot_printf(slot, "Starting command!\n");
 	/* Start command. */
 	WR2(slot, SDHCI_COMMAND_FLAGS, (cmd->opcode << 8) | (flags & 0xff));
 	/* Start timeout callout. */
@@ -1176,6 +1319,9 @@ sdhci_finish_command(struct sdhci_slot *slot)
 	uint32_t val;
 	uint8_t extra;
 
+	if (sdhci_debug > 1)
+		slot_printf(slot, "%s: called, err %d flags %d\n",
+			    __func__, slot->curcmd->error, slot->curcmd->flags);
 	slot->cmd_done = 1;
 	/*
 	 * Interrupt aggregation: Restore command interrupt.
@@ -1209,6 +1355,11 @@ sdhci_finish_command(struct sdhci_slot *slot)
 		} else
 			slot->curcmd->resp[0] = RD4(slot, SDHCI_RESPONSE);
 	}
+	if (sdhci_debug > 1)
+		printf("Resp: %02x %02x %02x %02x\n",
+		       slot->curcmd->resp[0], slot->curcmd->resp[1],
+		       slot->curcmd->resp[2], slot->curcmd->resp[3]);
+
 	/* If data ready - finish. */
 	if (slot->data_done)
 		sdhci_start(slot);
@@ -1289,6 +1440,11 @@ sdhci_start_data(struct sdhci_slot *slot, struct mmc_data *data)
 	    (data->len < 512) ? data->len : 512));
 	/* Set block count. */
 	WR2(slot, SDHCI_BLOCK_COUNT, (data->len + 511) / 512);
+
+	if (sdhci_debug > 1)
+		slot_printf(slot, "Block size: %02x, count %lu\n",
+		    (unsigned int)SDHCI_MAKE_BLKSZ(DMA_BOUNDARY, (data->len < 512) ? data->len : 512),
+		    (unsigned long)(data->len + 511) / 512);
 }
 
 void
@@ -1305,7 +1461,8 @@ sdhci_finish_data(struct sdhci_slot *slot)
 		    slot->intmask |= SDHCI_INT_RESPONSE);
 	}
 	/* Unload rest of data from DMA buffer. */
-	if (!slot->data_done && (slot->flags & SDHCI_USE_DMA)) {
+	if (!slot->data_done && (slot->flags & SDHCI_USE_DMA) &&
+	    slot->curcmd->data != NULL) {
 		if (data->flags & MMC_DATA_READ) {
 			left = data->len - slot->offset;
 			bus_dmamap_sync(slot->dmatag, slot->dmamap,
@@ -1329,6 +1486,47 @@ sdhci_finish_data(struct sdhci_slot *slot)
 		sdhci_start(slot);
 }
 
+#ifdef MMCCAM
+static void
+sdhci_start(struct sdhci_slot *slot)
+{
+        union ccb *ccb;
+
+	ccb = slot->ccb;
+	if (ccb == NULL)
+		return;
+
+        struct ccb_mmcio *mmcio;
+	mmcio = &ccb->mmcio;
+
+	if (!(slot->flags & CMD_STARTED)) {
+		slot->flags |= CMD_STARTED;
+		sdhci_start_command(slot, &mmcio->cmd);
+		return;
+	}
+
+	/*
+	 * Old stack doesn't use this!
+	 * Enabling this code causes significant performance degradation
+	 * and IRQ storms on BBB, Wandboard behaves fine.
+	 * Not using this code does no harm...
+	if (!(slot->flags & STOP_STARTED) && mmcio->stop.opcode != 0) {
+		slot->flags |= STOP_STARTED;
+		sdhci_start_command(slot, &mmcio->stop);
+		return;
+	}
+	*/
+	if (sdhci_debug > 1)
+		slot_printf(slot, "result: %d\n", mmcio->cmd.error);
+	if (mmcio->cmd.error == 0 &&
+	    (slot->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST)) {
+		sdhci_reset(slot, SDHCI_RESET_CMD);
+		sdhci_reset(slot, SDHCI_RESET_DATA);
+	}
+
+	sdhci_req_done(slot);
+}
+#else
 static void
 sdhci_start(struct sdhci_slot *slot)
 {
@@ -1343,23 +1541,25 @@ sdhci_start(struct sdhci_slot *slot)
 		sdhci_start_command(slot, req->cmd);
 		return;
 	}
-/* 	We don't need this until using Auto-CMD12 feature
-	if (!(slot->flags & STOP_STARTED) && req->stop) {
+	if ((slot->quirks & SDHCI_QUIRK_BROKEN_AUTO_STOP) &&
+	    !(slot->flags & STOP_STARTED) && req->stop) {
 		slot->flags |= STOP_STARTED;
 		sdhci_start_command(slot, req->stop);
 		return;
 	}
-*/
 	if (sdhci_debug > 1)
 		slot_printf(slot, "result: %d\n", req->cmd->error);
 	if (!req->cmd->error &&
-	    (slot->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST)) {
+	    ((slot->curcmd == req->stop &&
+	     (slot->quirks & SDHCI_QUIRK_BROKEN_AUTO_STOP)) ||
+	     (slot->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST))) {
 		sdhci_reset(slot, SDHCI_RESET_CMD);
 		sdhci_reset(slot, SDHCI_RESET_DATA);
 	}
 
 	sdhci_req_done(slot);
 }
+#endif
 
 int
 sdhci_generic_request(device_t brdev __unused, device_t reqdev,
@@ -1626,6 +1826,10 @@ sdhci_generic_intr(struct sdhci_slot *slot)
 		slot_printf(slot,
 		    "Card is consuming too much power!\n");
 		intmask &= ~SDHCI_INT_BUS_POWER;
+	}
+	/* Handle card interrupt. */
+	if (intmask & SDHCI_INT_CARD_INT) {
+		
 	}
 	/* The rest is unknown. */
 	if (intmask) {
@@ -1710,6 +1914,8 @@ sdhci_generic_write_ivar(device_t bus, device_t child, int which,
 	uint32_t clock, max_clock;
 	int i;
 
+	if (sdhci_debug > 1)
+		slot_printf(slot, "%s: var=%d\n", __func__, which);
 	switch (which) {
 	default:
 		return (EINVAL);
@@ -1775,4 +1981,326 @@ sdhci_generic_write_ivar(device_t bus, device_t child, int which,
 	return (0);
 }
 
+#ifdef MMCCAM
+/* CAM-related functions */
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <cam/cam_debug.h>
+#include <cam/cam_sim.h>
+#include <cam/cam_xpt_sim.h>
+
+void
+sdhci_start_slot(struct sdhci_slot *slot)
+{
+        if ((slot->devq = cam_simq_alloc(1)) == NULL) {
+                goto fail;
+        }
+
+        mtx_init(&slot->sim_mtx, "sdhcisim", NULL, MTX_DEF);
+        slot->sim = cam_sim_alloc(sdhci_cam_action, sdhci_cam_poll,
+                                  "sdhci_slot", slot, device_get_unit(slot->bus),
+                                  &slot->sim_mtx, 1, 1, slot->devq);
+
+        if (slot->sim == NULL) {
+                cam_simq_free(slot->devq);
+                slot_printf(slot, "cannot allocate CAM SIM\n");
+                goto fail;
+        }
+
+        mtx_lock(&slot->sim_mtx);
+        if (xpt_bus_register(slot->sim, slot->bus, 0) != 0) {
+                slot_printf(slot,
+                              "cannot register SCSI pass-through bus\n");
+                cam_sim_free(slot->sim, FALSE);
+                cam_simq_free(slot->devq);
+                mtx_unlock(&slot->sim_mtx);
+                goto fail;
+        }
+
+        mtx_unlock(&slot->sim_mtx);
+        /* End CAM-specific init */
+	slot->card_present = 0;
+	sdhci_card_task(slot, 0);
+        return;
+
+fail:
+        if (slot->sim != NULL) {
+                mtx_lock(&slot->sim_mtx);
+                xpt_bus_deregister(cam_sim_path(slot->sim));
+                cam_sim_free(slot->sim, FALSE);
+                mtx_unlock(&slot->sim_mtx);
+        }
+
+        if (slot->devq != NULL)
+                cam_simq_free(slot->devq);
+}
+
+static void
+sdhci_cam_handle_mmcio(struct cam_sim *sim, union ccb *ccb)
+{
+	struct sdhci_slot *slot;
+
+	slot = cam_sim_softc(sim);
+
+	sdhci_cam_request(slot, ccb);
+}
+
+void
+sdhci_cam_action(struct cam_sim *sim, union ccb *ccb)
+{
+	struct sdhci_slot *slot;
+
+	slot = cam_sim_softc(sim);
+	if (slot == NULL) {
+		ccb->ccb_h.status = CAM_SEL_TIMEOUT;
+		xpt_done(ccb);
+		return;
+	}
+
+	mtx_assert(&slot->sim_mtx, MA_OWNED);
+
+	switch (ccb->ccb_h.func_code) {
+	case XPT_PATH_INQ:
+	{
+		struct ccb_pathinq *cpi;
+
+		cpi = &ccb->cpi;
+		cpi->version_num = 1;
+		cpi->hba_inquiry = 0;
+		cpi->target_sprt = 0;
+		cpi->hba_misc = PIM_NOBUSRESET | PIM_SEQSCAN;
+		cpi->hba_eng_cnt = 0;
+		cpi->max_target = 0;
+		cpi->max_lun = 0;
+		cpi->initiator_id = 1;
+		cpi->maxio = MAXPHYS;
+		strncpy(cpi->sim_vid, "FreeBSD", SIM_IDLEN);
+		strncpy(cpi->hba_vid, "Deglitch Networks", HBA_IDLEN);
+		strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);
+		cpi->unit_number = cam_sim_unit(sim);
+		cpi->bus_id = cam_sim_bus(sim);
+		cpi->base_transfer_speed = 100; /* XXX WTF? */
+		cpi->protocol = PROTO_MMCSD;
+		cpi->protocol_version = SCSI_REV_0;
+		cpi->transport = XPORT_MMCSD;
+		cpi->transport_version = 0;
+
+		cpi->ccb_h.status = CAM_REQ_CMP;
+		break;
+	}
+	case XPT_GET_TRAN_SETTINGS:
+	{
+		struct ccb_trans_settings *cts = &ccb->cts;
+
+		if (sdhci_debug > 1)
+			slot_printf(slot, "Got XPT_GET_TRAN_SETTINGS\n");
+
+		cts->protocol = PROTO_MMCSD;
+		cts->protocol_version = 1;
+		cts->transport = XPORT_MMCSD;
+		cts->transport_version = 1;
+		cts->xport_specific.valid = 0;
+		cts->proto_specific.mmc.host_ocr = slot->host.host_ocr;
+		cts->proto_specific.mmc.host_f_min = slot->host.f_min;
+		cts->proto_specific.mmc.host_f_max = slot->host.f_max;
+		cts->proto_specific.mmc.host_caps = slot->host.caps;
+		memcpy(&cts->proto_specific.mmc.ios, &slot->host.ios, sizeof(struct mmc_ios));
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		break;
+	}
+	case XPT_SET_TRAN_SETTINGS:
+	{
+		if (sdhci_debug > 1)
+			slot_printf(slot, "Got XPT_SET_TRAN_SETTINGS\n");
+		sdhci_cam_settran_settings(slot, ccb);
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		break;
+	}
+	case XPT_RESET_BUS:
+		if (sdhci_debug > 1)
+			slot_printf(slot, "Got XPT_RESET_BUS, ACK it...\n");
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		break;
+	case XPT_MMC_IO:
+		/*
+		 * Here is the HW-dependent part of
+		 * sending the command to the underlying h/w
+		 * At some point in the future an interrupt comes.
+		 * Then the request will be marked as completed.
+		 */
+		if (sdhci_debug > 1)
+			slot_printf(slot, "Got XPT_MMC_IO\n");
+		ccb->ccb_h.status = CAM_REQ_INPROG;
+
+		sdhci_cam_handle_mmcio(sim, ccb);
+		return;
+		/* NOTREACHED */
+		break;
+	default:
+		ccb->ccb_h.status = CAM_REQ_INVALID;
+		break;
+	}
+	xpt_done(ccb);
+	return;
+}
+
+void
+sdhci_cam_poll(struct cam_sim *sim)
+{
+	return;
+}
+
+int sdhci_cam_get_possible_host_clock(struct sdhci_slot *slot, int proposed_clock) {
+	int max_clock, clock, i;
+
+	if (proposed_clock == 0)
+		return 0;
+	max_clock = slot->max_clk;
+	clock = max_clock;
+
+	if (slot->version < SDHCI_SPEC_300) {
+		for (i = 0; i < SDHCI_200_MAX_DIVIDER;
+		     i <<= 1) {
+			if (clock <= proposed_clock)
+				break;
+			clock >>= 1;
+		}
+	} else {
+		for (i = 0; i < SDHCI_300_MAX_DIVIDER;
+		     i += 2) {
+			if (clock <= proposed_clock)
+				break;
+			clock = max_clock / (i + 2);
+		}
+	}
+	return clock;
+}
+
+int
+sdhci_cam_settran_settings(struct sdhci_slot *slot, union ccb *ccb)
+{
+	struct mmc_ios *ios;
+	struct mmc_ios *new_ios;
+	struct ccb_trans_settings_mmc *cts;
+
+	ios = &slot->host.ios;
+
+	cts = &ccb->cts.proto_specific.mmc;
+	new_ios = &cts->ios;
+
+	/* Update only requested fields */
+	if (cts->ios_valid & MMC_CLK) {
+		ios->clock = sdhci_cam_get_possible_host_clock(slot, new_ios->clock);
+		slot_printf(slot, "Clock => %d\n", ios->clock);
+	}
+	if (cts->ios_valid & MMC_VDD) {
+		ios->vdd = new_ios->vdd;
+		slot_printf(slot, "VDD => %d\n", ios->vdd);
+	}
+	if (cts->ios_valid & MMC_CS) {
+		ios->chip_select = new_ios->chip_select;
+		slot_printf(slot, "CS => %d\n", ios->chip_select);
+	}
+	if (cts->ios_valid & MMC_BW) {
+		ios->bus_width = new_ios->bus_width;
+		slot_printf(slot, "Bus width => %d\n", ios->bus_width);
+	}
+	if (cts->ios_valid & MMC_PM) {
+		ios->power_mode = new_ios->power_mode;
+		slot_printf(slot, "Power mode => %d\n", ios->power_mode);
+	}
+	if (cts->ios_valid & MMC_BT) {
+		ios->timing = new_ios->timing;
+		slot_printf(slot, "Timing => %d\n", ios->timing);
+	}
+	if (cts->ios_valid & MMC_BM) {
+		ios->bus_mode = new_ios->bus_mode;
+		slot_printf(slot, "Bus mode => %d\n", ios->bus_mode);
+	}
+
+        /* XXX Provide a way to call a chip-specific IOS update, required for TI */
+	return (sdhci_cam_update_ios(slot));
+}
+
+int
+sdhci_cam_update_ios(struct sdhci_slot *slot)
+{
+	struct mmc_ios *ios = &slot->host.ios;
+
+	slot_printf(slot, "%s: power_mode=%d, clk=%d, bus_width=%d, timing=%d\n",
+		    __func__, ios->power_mode, ios->clock, ios->bus_width, ios->timing);
+	SDHCI_LOCK(slot);
+	/* Do full reset on bus power down to clear from any state. */
+	if (ios->power_mode == power_off) {
+		WR4(slot, SDHCI_SIGNAL_ENABLE, 0);
+		sdhci_init(slot);
+	}
+	/* Configure the bus. */
+	sdhci_set_clock(slot, ios->clock);
+	sdhci_set_power(slot, (ios->power_mode == power_off) ? 0 : ios->vdd);
+	if (ios->bus_width == bus_width_8) {
+		slot->hostctrl |= SDHCI_CTRL_8BITBUS;
+		slot->hostctrl &= ~SDHCI_CTRL_4BITBUS;
+	} else if (ios->bus_width == bus_width_4) {
+		slot->hostctrl &= ~SDHCI_CTRL_8BITBUS;
+		slot->hostctrl |= SDHCI_CTRL_4BITBUS;
+	} else if (ios->bus_width == bus_width_1) {
+		slot->hostctrl &= ~SDHCI_CTRL_8BITBUS;
+		slot->hostctrl &= ~SDHCI_CTRL_4BITBUS;
+	} else {
+		panic("Invalid bus width: %d", ios->bus_width);
+	}
+	if (ios->timing == bus_timing_hs &&
+	    !(slot->quirks & SDHCI_QUIRK_DONT_SET_HISPD_BIT))
+		slot->hostctrl |= SDHCI_CTRL_HISPD;
+	else
+		slot->hostctrl &= ~SDHCI_CTRL_HISPD;
+	WR1(slot, SDHCI_HOST_CONTROL, slot->hostctrl);
+	/* Some controllers like reset after bus changes. */
+	if(slot->quirks & SDHCI_QUIRK_RESET_ON_IOS)
+		sdhci_reset(slot, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
+
+	SDHCI_UNLOCK(slot);
+	return (0);
+}
+
+int
+sdhci_cam_request(struct sdhci_slot *slot, union ccb *ccb)
+{
+	struct ccb_mmcio *mmcio;
+
+	mmcio = &ccb->mmcio;
+
+	SDHCI_LOCK(slot);
+/*	if (slot->req != NULL) {
+		SDHCI_UNLOCK(slot);
+		return (EBUSY);
+	}
+*/
+	if (sdhci_debug > 1) {
+		slot_printf(slot, "CMD%u arg %#x flags %#x dlen %u dflags %#x\n",
+			    mmcio->cmd.opcode, mmcio->cmd.arg, mmcio->cmd.flags,
+			    mmcio->cmd.data != NULL ? (unsigned int) mmcio->cmd.data->len : 0,
+			    mmcio->cmd.data != NULL ? mmcio->cmd.data->flags: 0);
+	}
+	if (mmcio->cmd.data != NULL) {
+		if (mmcio->cmd.data->len == 0 || mmcio->cmd.data->flags == 0)
+			panic("data->len = %d, data->flags = %d -- something is b0rked",
+			      (int)mmcio->cmd.data->len, mmcio->cmd.data->flags);
+	}
+	slot->ccb = ccb;
+	slot->flags = 0;
+	sdhci_start(slot);
+	SDHCI_UNLOCK(slot);
+	if (dumping) {
+		while (slot->ccb != NULL) {
+			sdhci_generic_intr(slot);
+			DELAY(10);
+		}
+	}
+	return (0);
+}
+#endif /* MMCCAM */
+
 MODULE_VERSION(sdhci, 1);
+
diff --git a/sys/dev/sdhci/sdhci.h b/sys/dev/sdhci/sdhci.h
index 0b299150b99..fa2d949125b 100644
--- a/sys/dev/sdhci/sdhci.h
+++ b/sys/dev/sdhci/sdhci.h
@@ -28,6 +28,8 @@
 #ifndef	__SDHCI_H__
 #define	__SDHCI_H__
 
+#include "opt_mmccam.h"
+
 #define	DMA_BLOCK_SIZE	4096
 #define	DMA_BOUNDARY	0	/* DMA reload every 4K */
 
@@ -87,6 +89,8 @@
 #define	SDHCI_QUIRK_CAPS_BIT63_FOR_MMC_HS400		(1 << 26)
 /* Controller support for SDHCI_CTRL2_PRESET_VALUE is broken. */
 #define	SDHCI_QUIRK_PRESET_VALUE_BROKEN			(1 << 27)
+/* Controller does not support or the support for ACMD12 is broken. */
+#define	SDHCI_QUIRK_BROKEN_AUTO_STOP			(1 << 28)
 
 /*
  * Controller registers
@@ -365,6 +369,15 @@ struct sdhci_slot {
 #define	SDHCI_USE_DMA		4	/* Use DMA for this req. */
 #define	PLATFORM_DATA_STARTED	8	/* Data xfer is handled by platform */
 	struct mtx	mtx;		/* Slot mutex */
+
+#ifdef MMCCAM
+	/* CAM stuff */
+	union ccb	*ccb;
+	struct cam_devq		*devq;
+	struct cam_sim		*sim;
+	struct mtx		sim_mtx;
+	u_char			card_present; /* XXX Maybe derive this from elsewhere? */
+#endif
 };
 
 int sdhci_generic_read_ivar(device_t bus, device_t child, int which,
@@ -392,3 +405,4 @@ void sdhci_generic_set_uhs_timing(device_t brdev, struct sdhci_slot *slot);
 void sdhci_handle_card_present(struct sdhci_slot *slot, bool is_present);
 
 #endif	/* __SDHCI_H__ */
+
diff --git a/sys/dev/sdhci/sdhci_acpi.c b/sys/dev/sdhci/sdhci_acpi.c
index 54c2c56cc81..cf1b24cecaf 100644
--- a/sys/dev/sdhci/sdhci_acpi.c
+++ b/sys/dev/sdhci/sdhci_acpi.c
@@ -381,4 +381,7 @@ static devclass_t sdhci_acpi_devclass;
 DRIVER_MODULE(sdhci_acpi, acpi, sdhci_acpi_driver, sdhci_acpi_devclass, NULL,
     NULL);
 MODULE_DEPEND(sdhci_acpi, sdhci, 1, 1, 1);
+
+#ifndef MMCCAM
 MMC_DECLARE_BRIDGE(sdhci_acpi);
+#endif
diff --git a/sys/dev/sdhci/sdhci_fdt.c b/sys/dev/sdhci/sdhci_fdt.c
index 2e1b30e4b37..4cadafcae36 100644
--- a/sys/dev/sdhci/sdhci_fdt.c
+++ b/sys/dev/sdhci/sdhci_fdt.c
@@ -57,7 +57,17 @@ __FBSDID("$FreeBSD$");
 #include "mmcbr_if.h"
 #include "sdhci_if.h"
 
-#define	MAX_SLOTS	6
+#define	MAX_SLOTS		6
+#define	SDHCI_FDT_ARMADA38X	1
+#define	SDHCI_FDT_GENERIC	2
+#define	SDHCI_FDT_XLNX_ZY7	3
+
+static struct ofw_compat_data compat_data[] = {
+	{ "marvell,armada-380-sdhci",	SDHCI_FDT_ARMADA38X },
+	{ "sdhci_generic",		SDHCI_FDT_GENERIC },
+	{ "xlnx,zy7_sdhci",		SDHCI_FDT_XLNX_ZY7 },
+	{ NULL, 0 }
+};
 
 struct sdhci_fdt_softc {
 	device_t	dev;		/* Controller device */
@@ -70,6 +80,9 @@ struct sdhci_fdt_softc {
 	int		num_slots;	/* Number of slots on this controller*/
 	struct sdhci_slot slots[MAX_SLOTS];
 	struct resource	*mem_res[MAX_SLOTS];	/* Memory resource */
+
+	bool		wp_inverted;	/* WP pin is inverted */
+	bool		no_18v;		/* No 1.8V support */
 };
 
 static uint8_t
@@ -110,8 +123,13 @@ static uint32_t
 sdhci_fdt_read_4(device_t dev, struct sdhci_slot *slot, bus_size_t off)
 {
 	struct sdhci_fdt_softc *sc = device_get_softc(dev);
+	uint32_t val32;
+
+	val32 = bus_read_4(sc->mem_res[slot->num], off);
+	if (off == SDHCI_CAPABILITIES && sc->no_18v)
+		val32 &= ~SDHCI_CAN_VDD_180;
 
-	return (bus_read_4(sc->mem_res[slot->num], off));
+	return (val32);
 }
 
 static void
@@ -151,6 +169,14 @@ sdhci_fdt_intr(void *arg)
 		sdhci_generic_intr(&sc->slots[i]);
 }
 
+static int
+sdhci_fdt_get_ro(device_t bus, device_t dev)
+{
+	struct sdhci_fdt_softc *sc = device_get_softc(bus);
+
+	return (sdhci_generic_get_ro(bus, dev) ^ sc->wp_inverted);
+}
+
 static int
 sdhci_fdt_probe(device_t dev)
 {
@@ -165,13 +191,21 @@ sdhci_fdt_probe(device_t dev)
 	if (!ofw_bus_status_okay(dev))
 		return (ENXIO);
 
-	if (ofw_bus_is_compatible(dev, "sdhci_generic")) {
+	switch (ofw_bus_search_compatible(dev, compat_data)->ocd_data) {
+	case SDHCI_FDT_ARMADA38X:
+		sc->quirks = SDHCI_QUIRK_BROKEN_AUTO_STOP;
+		device_set_desc(dev, "ARMADA38X SDHCI controller");
+		break;
+	case SDHCI_FDT_GENERIC:
 		device_set_desc(dev, "generic fdt SDHCI controller");
-	} else if (ofw_bus_is_compatible(dev, "xlnx,zy7_sdhci")) {
+		break;
+	case SDHCI_FDT_XLNX_ZY7:
 		sc->quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK;
 		device_set_desc(dev, "Zynq-7000 generic fdt SDHCI controller");
-	} else
+		break;
+	default:
 		return (ENXIO);
+	}
 
 	node = ofw_bus_get_node(dev);
 
@@ -182,6 +216,10 @@ sdhci_fdt_probe(device_t dev)
 		sc->num_slots = cid;
 	if ((OF_getencprop(node, "max-frequency", &cid, sizeof(cid))) > 0)
 		sc->max_clk = cid;
+	if (OF_hasprop(node, "no-1-8-v"))
+		sc->no_18v = true;
+	if (OF_hasprop(node, "wp-inverted"))
+		sc->wp_inverted = true;
 
 	return (0);
 }
@@ -279,7 +317,7 @@ static device_method_t sdhci_fdt_methods[] = {
 	/* mmcbr_if */
 	DEVMETHOD(mmcbr_update_ios,	sdhci_generic_update_ios),
 	DEVMETHOD(mmcbr_request,	sdhci_generic_request),
-	DEVMETHOD(mmcbr_get_ro,		sdhci_generic_get_ro),
+	DEVMETHOD(mmcbr_get_ro,		sdhci_fdt_get_ro),
 	DEVMETHOD(mmcbr_acquire_host,	sdhci_generic_acquire_host),
 	DEVMETHOD(mmcbr_release_host,	sdhci_generic_release_host),
 
@@ -307,3 +345,4 @@ DRIVER_MODULE(sdhci_fdt, simplebus, sdhci_fdt_driver, sdhci_fdt_devclass,
     NULL, NULL);
 MODULE_DEPEND(sdhci_fdt, sdhci, 1, 1, 1);
 MMC_DECLARE_BRIDGE(sdhci_fdt);
+
diff --git a/sys/dev/sdhci/sdhci_pci.c b/sys/dev/sdhci/sdhci_pci.c
index 7063ea5c262..86b90676d0d 100644
--- a/sys/dev/sdhci/sdhci_pci.c
+++ b/sys/dev/sdhci/sdhci_pci.c
@@ -26,6 +26,8 @@
 #include <sys/cdefs.h>
 __FBSDID("$FreeBSD$");
 
+#include "opt_mmccam.h"
+
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/bus.h>
@@ -393,8 +395,9 @@ sdhci_pci_attach(device_t dev)
 		device_printf(dev, "Can't setup IRQ\n");
 	pci_enable_busmaster(dev);
 	/* Process cards detection. */
-	for (i = 0; i < sc->num_slots; i++)
+	for (i = 0; i < sc->num_slots; i++) {
 		sdhci_start_slot(&sc->slots[i]);
+	}
 
 	return (0);
 }
@@ -515,4 +518,7 @@ static devclass_t sdhci_pci_devclass;
 DRIVER_MODULE(sdhci_pci, pci, sdhci_pci_driver, sdhci_pci_devclass, NULL,
     NULL);
 MODULE_DEPEND(sdhci_pci, sdhci, 1, 1, 1);
+
+#ifndef MMCCAM
 MMC_DECLARE_BRIDGE(sdhci_pci);
+#endif
diff --git a/sys/modules/sdhci/Makefile b/sys/modules/sdhci/Makefile
index 941b4d51ada..158ed4cd945 100644
--- a/sys/modules/sdhci/Makefile
+++ b/sys/modules/sdhci/Makefile
@@ -3,6 +3,6 @@
 .PATH: ${SRCTOP}/sys/dev/sdhci
 
 KMOD=	sdhci
-SRCS=	sdhci.c sdhci.h sdhci_if.c sdhci_if.h device_if.h bus_if.h mmcbr_if.h
+SRCS=	sdhci.c sdhci.h sdhci_if.c sdhci_if.h device_if.h bus_if.h mmcbr_if.h opt_mmccam.h opt_cam.h
 
 .include <bsd.kmod.mk>
diff --git a/usr.bin/sdiotool/Makefile b/usr.bin/sdiotool/Makefile
new file mode 100644
index 00000000000..76d091f4295
--- /dev/null
+++ b/usr.bin/sdiotool/Makefile
@@ -0,0 +1,9 @@
+# $FreeBSD$
+
+PROG=	sdiotool
+SRCS=	sdiotool.c
+
+LIBADD= cam util
+MAN=
+
+.include <bsd.prog.mk>
diff --git a/usr.bin/sdiotool/brcmfmac_bus.h b/usr.bin/sdiotool/brcmfmac_bus.h
new file mode 100644
index 00000000000..27baad34d74
--- /dev/null
+++ b/usr.bin/sdiotool/brcmfmac_bus.h
@@ -0,0 +1,28 @@
+/*-
+ * SPDX-License-Identifier: ISC
+ *
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * $FreeBSD$
+ */
+/* The level of bus communication with the dongle */
+enum brcmf_bus_state {
+	BRCMF_BUS_DOWN,		/* Not ready for frame transfers */
+	BRCMF_BUS_UP		/* Ready for frame transfers */
+};
+
+struct brcmf_bus {
+	enum brcmf_bus_state state;
+};
diff --git a/usr.bin/sdiotool/brcmfmac_sdio.h b/usr.bin/sdiotool/brcmfmac_sdio.h
new file mode 100644
index 00000000000..5a972d99816
--- /dev/null
+++ b/usr.bin/sdiotool/brcmfmac_sdio.h
@@ -0,0 +1,162 @@
+/*-
+ * SPDX-License-Identifier: ISC
+ *
+ * Copyright (c) 2010 Broadcom Corporation
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * $FreeBSD$
+ */
+#define SDIO_FUNC_0		0
+#define SDIO_FUNC_1		1
+#define SDIO_FUNC_2		2
+
+#define SDIOD_FBR_SIZE		0x100
+
+/* io_en */
+#define SDIO_FUNC_ENABLE_1	0x02
+#define SDIO_FUNC_ENABLE_2	0x04
+
+/* io_rdys */
+#define SDIO_FUNC_READY_1	0x02
+#define SDIO_FUNC_READY_2	0x04
+
+/* intr_status */
+#define INTR_STATUS_FUNC1	0x2
+#define INTR_STATUS_FUNC2	0x4
+
+/* Maximum number of I/O funcs */
+#define SDIOD_MAX_IOFUNCS	7
+
+/* mask of register map */
+#define REG_F0_REG_MASK		0x7FF
+#define REG_F1_MISC_MASK	0x1FFFF
+
+/* as of sdiod rev 0, supports 3 functions */
+#define SBSDIO_NUM_FUNCTION		3
+
+/* function 0 vendor specific CCCR registers */
+#define SDIO_CCCR_BRCM_CARDCAP			0xf0
+#define SDIO_CCCR_BRCM_CARDCAP_CMD14_SUPPORT	0x02
+#define SDIO_CCCR_BRCM_CARDCAP_CMD14_EXT	0x04
+#define SDIO_CCCR_BRCM_CARDCAP_CMD_NODEC	0x08
+#define SDIO_CCCR_BRCM_CARDCTRL		0xf1
+#define SDIO_CCCR_BRCM_CARDCTRL_WLANRESET	0x02
+#define SDIO_CCCR_BRCM_SEPINT			0xf2
+
+#define  SDIO_SEPINT_MASK		0x01
+#define  SDIO_SEPINT_OE			0x02
+#define  SDIO_SEPINT_ACT_HI		0x04
+
+/* function 1 miscellaneous registers */
+
+/* sprom command and status */
+#define SBSDIO_SPROM_CS			0x10000
+/* sprom info register */
+#define SBSDIO_SPROM_INFO		0x10001
+/* sprom indirect access data byte 0 */
+#define SBSDIO_SPROM_DATA_LOW		0x10002
+/* sprom indirect access data byte 1 */
+#define SBSDIO_SPROM_DATA_HIGH		0x10003
+/* sprom indirect access addr byte 0 */
+#define SBSDIO_SPROM_ADDR_LOW		0x10004
+/* gpio select */
+#define SBSDIO_GPIO_SELECT		0x10005
+/* gpio output */
+#define SBSDIO_GPIO_OUT			0x10006
+/* gpio enable */
+#define SBSDIO_GPIO_EN			0x10007
+/* rev < 7, watermark for sdio device */
+#define SBSDIO_WATERMARK		0x10008
+/* control busy signal generation */
+#define SBSDIO_DEVICE_CTL		0x10009
+
+/* SB Address Window Low (b15) */
+#define SBSDIO_FUNC1_SBADDRLOW		0x1000A
+/* SB Address Window Mid (b23:b16) */
+#define SBSDIO_FUNC1_SBADDRMID		0x1000B
+/* SB Address Window High (b31:b24)    */
+#define SBSDIO_FUNC1_SBADDRHIGH		0x1000C
+/* Frame Control (frame term/abort) */
+#define SBSDIO_FUNC1_FRAMECTRL		0x1000D
+/* ChipClockCSR (ALP/HT ctl/status) */
+#define SBSDIO_FUNC1_CHIPCLKCSR		0x1000E
+/* SdioPullUp (on cmd, d0-d2) */
+#define SBSDIO_FUNC1_SDIOPULLUP		0x1000F
+/* Write Frame Byte Count Low */
+#define SBSDIO_FUNC1_WFRAMEBCLO		0x10019
+/* Write Frame Byte Count High */
+#define SBSDIO_FUNC1_WFRAMEBCHI		0x1001A
+/* Read Frame Byte Count Low */
+#define SBSDIO_FUNC1_RFRAMEBCLO		0x1001B
+/* Read Frame Byte Count High */
+#define SBSDIO_FUNC1_RFRAMEBCHI		0x1001C
+/* MesBusyCtl (rev 11) */
+#define SBSDIO_FUNC1_MESBUSYCTRL	0x1001D
+/* Sdio Core Rev 12 */
+#define SBSDIO_FUNC1_WAKEUPCTRL		0x1001E
+#define SBSDIO_FUNC1_WCTRL_ALPWAIT_MASK		0x1
+#define SBSDIO_FUNC1_WCTRL_ALPWAIT_SHIFT	0
+#define SBSDIO_FUNC1_WCTRL_HTWAIT_MASK		0x2
+#define SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT		1
+#define SBSDIO_FUNC1_SLEEPCSR		0x1001F
+#define SBSDIO_FUNC1_SLEEPCSR_KSO_MASK		0x1
+#define SBSDIO_FUNC1_SLEEPCSR_KSO_SHIFT		0
+#define SBSDIO_FUNC1_SLEEPCSR_KSO_EN		1
+#define SBSDIO_FUNC1_SLEEPCSR_DEVON_MASK	0x2
+#define SBSDIO_FUNC1_SLEEPCSR_DEVON_SHIFT	1
+
+#define SBSDIO_FUNC1_MISC_REG_START	0x10000	/* f1 misc register start */
+#define SBSDIO_FUNC1_MISC_REG_LIMIT	0x1001F	/* f1 misc register end */
+
+/* function 1 OCP space */
+
+/* sb offset addr is <= 15 bits, 32k */
+#define SBSDIO_SB_OFT_ADDR_MASK		0x07FFF
+#define SBSDIO_SB_OFT_ADDR_LIMIT	0x08000
+/* with b15, maps to 32-bit SB access */
+#define SBSDIO_SB_ACCESS_2_4B_FLAG	0x08000
+
+/* valid bits in SBSDIO_FUNC1_SBADDRxxx regs */
+
+#define SBSDIO_SBADDRLOW_MASK		0x80	/* Valid bits in SBADDRLOW */
+#define SBSDIO_SBADDRMID_MASK		0xff	/* Valid bits in SBADDRMID */
+#define SBSDIO_SBADDRHIGH_MASK		0xffU	/* Valid bits in SBADDRHIGH */
+/* Address bits from SBADDR regs */
+#define SBSDIO_SBWINDOW_MASK		0xffff8000
+
+#define SDIOH_READ              0	/* Read request */
+#define SDIOH_WRITE             1	/* Write request */
+
+#define SDIOH_DATA_FIX          0	/* Fixed addressing */
+#define SDIOH_DATA_INC          1	/* Incremental addressing */
+
+/* internal return code */
+#define SUCCESS	0
+#define ERROR	1
+
+/* Packet alignment for most efficient SDIO (can change based on platform) */
+#define BRCMF_SDALIGN	(1 << 6)
+
+/**
+ * enum brcmf_sdiod_state - the state of the bus.
+ *
+ * @BRCMF_SDIOD_DOWN: Device can be accessed, no DPC.
+ * @BRCMF_SDIOD_DATA: Ready for data transfers, DPC enabled.
+ * @BRCMF_SDIOD_NOMEDIUM: No medium access to dongle possible.
+ */
+enum brcmf_sdiod_state {
+	BRCMF_SDIOD_DOWN,
+	BRCMF_SDIOD_DATA,
+	BRCMF_SDIOD_NOMEDIUM
+};
diff --git a/usr.bin/sdiotool/cam_sdio.c b/usr.bin/sdiotool/cam_sdio.c
new file mode 100644
index 00000000000..13576bbf188
--- /dev/null
+++ b/usr.bin/sdiotool/cam_sdio.c
@@ -0,0 +1,440 @@
+/*-
+ * Copyright (c) 2017 Ilya Bakulin
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "cam_sdio.h"
+
+/* Use CMD52 to read or write a single byte */
+int
+sdio_rw_direct(struct cam_device *dev,
+	       uint8_t func_number,
+	       uint32_t addr,
+	       uint8_t is_write,
+	       uint8_t *data, uint8_t *resp) {
+	union ccb *ccb;
+	uint32_t flags;
+	uint32_t arg;
+	int retval = 0;
+
+	ccb = cam_getccb(dev);
+	if (ccb == NULL) {
+		warnx("%s: error allocating CCB", __func__);
+		return (-1);
+	}
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(union ccb) - sizeof(struct ccb_hdr));
+
+	flags = MMC_RSP_R5 | MMC_CMD_AC;
+	arg = SD_IO_RW_FUNC(func_number) | SD_IO_RW_ADR(addr);
+	if (is_write)
+		arg |= SD_IO_RW_WR | SD_IO_RW_RAW | SD_IO_RW_DAT(*data);
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_NONE,
+		       /*mmc_opcode*/ SD_IO_RW_DIRECT,
+		       /*mmc_arg*/ arg,
+		       /*mmc_flags*/ flags,
+		       /*mmc_data*/ 0,
+		       /*timeout*/ 5000);
+
+	if (((retval = cam_send_ccb(dev, ccb)) < 0)
+	    || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		const char warnstr[] = "error sending command";
+
+		if (retval < 0)
+			warn(warnstr);
+		else
+			warnx(warnstr);
+		return (-1);
+	}
+
+	*resp = ccb->mmcio.cmd.resp[0] & 0xFF;
+	cam_freeccb(ccb);
+	return (retval);
+}
+
+/*
+ * CMD53 -- IO_RW_EXTENDED
+ * Use to read or write memory blocks
+ *
+ * is_increment=1: FIFO mode
+ * blk_count > 0: block mode
+ */
+int
+sdio_rw_extended(struct cam_device *dev,
+		 uint8_t func_number,
+		 uint32_t addr,
+		 uint8_t is_write,
+		 caddr_t data, size_t datalen,
+		 uint8_t is_increment,
+		 uint16_t blk_count) {
+	union ccb *ccb;
+	uint32_t flags;
+	uint32_t arg;
+	uint32_t cam_flags;
+	uint8_t resp;
+	struct mmc_data mmcd;
+	int retval = 0;
+
+	if (blk_count != 0) {
+		warnx("%s: block mode is not supported yet", __func__);
+		return (-1);
+	}
+
+	ccb = cam_getccb(dev);
+	if (ccb == NULL) {
+		warnx("%s: error allocating CCB", __func__);
+		return (-1);
+	}
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(union ccb) - sizeof(struct ccb_hdr));
+
+	flags = MMC_RSP_R5 | MMC_CMD_ADTC;
+	arg = SD_IO_RW_FUNC(func_number) | SD_IO_RW_ADR(addr) |
+		SD_IOE_RW_LEN(datalen);
+
+	if (is_increment)
+		arg |= SD_IO_RW_INCR;
+
+	mmcd.data = data;
+	mmcd.len = datalen;
+	mmcd.xfer_len = 0; /* not used by MMCCAM */
+	mmcd.mrq = NULL; /* not used by MMCCAM */
+
+	if (is_write) {
+		arg |= SD_IO_RW_WR;
+		cam_flags = CAM_DIR_OUT;
+		mmcd.flags = MMC_DATA_WRITE;
+	} else {
+		cam_flags = CAM_DIR_IN;
+		mmcd.flags = MMC_DATA_READ;
+	}
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ cam_flags,
+		       /*mmc_opcode*/ SD_IO_RW_EXTENDED,
+		       /*mmc_arg*/ arg,
+		       /*mmc_flags*/ flags,
+		       /*mmc_data*/ &mmcd,
+		       /*timeout*/ 5000);
+
+	if (((retval = cam_send_ccb(dev, ccb)) < 0)
+	    || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		const char warnstr[] = "error sending command";
+
+		if (retval < 0)
+			warn(warnstr);
+		else
+			warnx(warnstr);
+		return (-1);
+	}
+
+	resp = ccb->mmcio.cmd.resp[0] & 0xFF;
+	if (resp != 0)
+		warn("Response from CMD53 is not 0?!");
+	cam_freeccb(ccb);
+	return (retval);
+}
+
+
+int
+sdio_read_bool_for_func(struct cam_device *dev, uint32_t addr, uint8_t func_number, uint8_t *is_enab) {
+	uint8_t resp;
+	int ret;
+
+	ret = sdio_rw_direct(dev, 0, addr, 0, NULL, &resp);
+	if (ret < 0)
+		return ret;
+
+	*is_enab = (resp & (1 << func_number)) > 0 ? 1 : 0;
+
+	return (0);
+}
+
+int
+sdio_set_bool_for_func(struct cam_device *dev, uint32_t addr, uint8_t func_number, int enable) {
+	uint8_t resp;
+	int ret;
+	uint8_t is_enabled;
+
+	ret = sdio_rw_direct(dev, 0, addr, 0, NULL, &resp);
+	if (ret != 0)
+		return ret;
+
+	is_enabled = resp & (1 << func_number);
+	if ((is_enabled !=0 && enable == 1) || (is_enabled == 0 && enable == 0))
+		return 0;
+
+	if (enable)
+		resp |= 1 << func_number;
+	else
+		resp &= ~ (1 << func_number);
+
+	ret = sdio_rw_direct(dev, 0, addr, 1, &resp, &resp);
+
+	return ret;
+}
+
+/* Conventional I/O functions */
+uint8_t
+sdio_read_1(struct cam_device *dev, uint8_t func_number, uint32_t addr, int *ret) {
+	uint8_t val;
+	*ret = sdio_rw_direct(dev, func_number, addr, 0, NULL, &val);
+	return val;
+}
+
+int
+sdio_write_1(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint8_t val) {
+	uint8_t _val;
+	return sdio_rw_direct(dev, func_number, addr, 0, &val, &_val);
+}
+
+uint16_t
+sdio_read_2(struct cam_device *dev, uint8_t func_number, uint32_t addr, int *ret) {
+	uint16_t val;
+	*ret = sdio_rw_extended(dev, func_number, addr,
+				/* is_write */ 0,
+				/* data */ (caddr_t) &val,
+				/* datalen */ sizeof(val),
+				/* is_increment */ 1,
+				/* blk_count */ 0
+		);
+	return val;
+}
+
+
+int
+sdio_write_2(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint16_t val) {
+	return sdio_rw_extended(dev, func_number, addr,
+				/* is_write */ 1,
+				/* data */ (caddr_t) &val,
+				/* datalen */ sizeof(val),
+				/* is_increment */ 1,
+				/* blk_count */ 0
+		);
+}
+
+uint32_t
+sdio_read_4(struct cam_device *dev, uint8_t func_number, uint32_t addr, int *ret) {
+	uint32_t val;
+	*ret = sdio_rw_extended(dev, func_number, addr,
+				/* is_write */ 0,
+				/* data */ (caddr_t) &val,
+				/* datalen */ sizeof(val),
+				/* is_increment */ 1,
+				/* blk_count */ 0
+		);
+	return val;
+}
+
+
+int
+sdio_write_4(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint32_t val) {
+	return sdio_rw_extended(dev, func_number, addr,
+				/* is_write */ 1,
+				/* data */ (caddr_t) &val,
+				/* datalen */ sizeof(val),
+				/* is_increment */ 1,
+				/* blk_count */ 0
+		);
+}
+
+/* Higher-level wrappers for certain management operations */
+int
+sdio_is_func_ready(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab) {
+	return sdio_read_bool_for_func(dev, SD_IO_CCCR_FN_READY, func_number, is_enab);
+}
+
+int
+sdio_is_func_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab) {
+	return sdio_read_bool_for_func(dev, SD_IO_CCCR_FN_ENABLE, func_number, is_enab);
+}
+
+int
+sdio_func_enable(struct cam_device *dev, uint8_t func_number, int enable) {
+	return sdio_set_bool_for_func(dev, SD_IO_CCCR_FN_ENABLE, func_number, enable);
+}
+
+int
+sdio_is_func_intr_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab) {
+	return sdio_read_bool_for_func(dev, SD_IO_CCCR_INT_ENABLE, func_number, is_enab);
+}
+
+int
+sdio_func_intr_enable(struct cam_device *dev, uint8_t func_number, int enable) {
+	return sdio_set_bool_for_func(dev, SD_IO_CCCR_INT_ENABLE, func_number, enable);
+}
+
+int
+sdio_card_set_bus_width(struct cam_device *dev, enum mmc_bus_width bw) {
+	int ret;
+	uint8_t ctl_val;
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_BUS_WIDTH, 0, NULL, &ctl_val);
+	if (ret < 0) {
+		warn("Error getting CCCR_BUS_WIDTH value");
+		return ret;
+	}
+	ctl_val &= ~0x3;
+	switch (bw) {
+	case bus_width_1:
+		/* Already set to 1-bit */
+		break;
+	case bus_width_4:
+		ctl_val |= CCCR_BUS_WIDTH_4;
+		break;
+	case bus_width_8:
+		warn("Cannot do 8-bit on SDIO yet");
+		return -1;
+		break;
+	}
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_BUS_WIDTH, 1, &ctl_val, &ctl_val);
+	if (ret < 0) {
+		warn("Error setting CCCR_BUS_WIDTH value");
+		return ret;
+	}
+	return ret;
+}
+
+int
+sdio_func_read_cis(struct cam_device *dev, uint8_t func_number,
+		   uint32_t cis_addr, struct cis_info *info) {
+	uint8_t tuple_id, tuple_len, tuple_count;
+	uint32_t addr;
+
+	char *cis1_info[4];
+	int start, i, ch, count, ret;
+	char cis1_info_buf[256];
+
+	tuple_count = 0; /* Use to prevent infinite loop in case of parse errors */
+	memset(cis1_info_buf, 0, 256);
+	do {
+		addr = cis_addr;
+		tuple_id = sdio_read_1(dev, 0, addr++, &ret);
+		if (tuple_id == SD_IO_CISTPL_END)
+			break;
+		if (tuple_id == 0) {
+			cis_addr++;
+			continue;
+		}
+		tuple_len = sdio_read_1(dev, 0, addr++, &ret);
+		if (tuple_len == 0 && tuple_id != 0x00) {
+			warn("Parse error: 0-length tuple %02X\n", tuple_id);
+			return -1;
+		}
+
+		switch (tuple_id) {
+		case SD_IO_CISTPL_VERS_1:
+			addr += 2;
+			for (count = 0, start = 0, i = 0;
+			     (count < 4) && ((i + 4) < 256); i++) {
+				ch = sdio_read_1(dev, 0, addr + i, &ret);
+				printf("count=%d, start=%d, i=%d, Got %c (0x%02x)\n", count, start, i, ch, ch);
+				if (ch == 0xff)
+					break;
+				cis1_info_buf[i] = ch;
+				if (ch == 0) {
+					cis1_info[count] =
+						cis1_info_buf + start;
+					start = i + 1;
+					count++;
+				}
+			}
+			printf("Card info:");
+			for (i=0; i<4; i++)
+				if (cis1_info[i])
+					printf(" %s", cis1_info[i]);
+			printf("\n");
+			break;
+		case SD_IO_CISTPL_MANFID:
+			info->man_id =  sdio_read_1(dev, 0, addr++, &ret);
+			info->man_id |= sdio_read_1(dev, 0, addr++, &ret) << 8;
+
+			info->prod_id =  sdio_read_1(dev, 0, addr++, &ret);
+			info->prod_id |= sdio_read_1(dev, 0, addr++, &ret) << 8;
+			break;
+		case SD_IO_CISTPL_FUNCID:
+			/* not sure if we need to parse it? */
+			break;
+		case SD_IO_CISTPL_FUNCE:
+			if (tuple_len < 4) {
+				printf("FUNCE is too short: %d\n", tuple_len);
+				break;
+			}
+			if (func_number == 0) {
+				/* skip extended_data */
+				addr++;
+				info->max_block_size  = sdio_read_1(dev, 0, addr++, &ret);
+				info->max_block_size |= sdio_read_1(dev, 0, addr++, &ret) << 8;
+			} else {
+				info->max_block_size  = sdio_read_1(dev, 0, addr + 0xC, &ret);
+				info->max_block_size |= sdio_read_1(dev, 0, addr + 0xD, &ret) << 8;
+			}
+			break;
+		default:
+			warnx("Skipping tuple ID %02X len %02X\n", tuple_id, tuple_len);
+		}
+		cis_addr += tuple_len + 2;
+		tuple_count++;
+	} while (tuple_count < 20);
+
+	return 0;
+}
+
+uint32_t
+sdio_get_common_cis_addr(struct cam_device *dev) {
+	uint32_t addr;
+	int ret;
+
+	addr =  sdio_read_1(dev, 0, SD_IO_CCCR_CISPTR, &ret);
+	addr |= sdio_read_1(dev, 0, SD_IO_CCCR_CISPTR + 1, &ret) << 8;
+	addr |= sdio_read_1(dev, 0, SD_IO_CCCR_CISPTR + 2, &ret) << 16;
+
+	if (addr < SD_IO_CIS_START || addr > SD_IO_CIS_START + SD_IO_CIS_SIZE) {
+		warn("Bad CIS address: %04X\n", addr);
+		addr = 0;
+	}
+
+	return addr;
+}
+
+void sdio_card_reset(struct cam_device *dev) {
+	int ret;
+	uint8_t ctl_val;
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_CTL, 0, NULL, &ctl_val);
+	if (ret < 0)
+		errx(1, "Error getting CCCR_CTL value");
+	ctl_val |= CCCR_CTL_RES;
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_CTL, 1, &ctl_val, &ctl_val);
+	if (ret < 0)
+		errx(1, "Error setting CCCR_CTL value");
+}
diff --git a/usr.bin/sdiotool/cam_sdio.h b/usr.bin/sdiotool/cam_sdio.h
new file mode 100644
index 00000000000..32d8d079de0
--- /dev/null
+++ b/usr.bin/sdiotool/cam_sdio.h
@@ -0,0 +1,97 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2017 Ilya Bakulin
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/ioctl.h>
+#include <sys/stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/endian.h>
+#include <sys/sbuf.h>
+#include <sys/mman.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <err.h>
+#include <libutil.h>
+#include <unistd.h>
+
+#include <cam/cam.h>
+#include <cam/cam_debug.h>
+#include <cam/cam_ccb.h>
+#include <cam/mmc/mmc_all.h>
+#include <camlib.h>
+
+struct cis_info {
+	uint16_t man_id;
+	uint16_t prod_id;
+	uint16_t max_block_size;
+};
+
+int sdio_rw_direct(struct cam_device *dev,
+			  uint8_t func_number,
+			  uint32_t addr,
+			  uint8_t is_write,
+			  uint8_t *data,
+			  uint8_t *resp);
+int
+sdio_rw_extended(struct cam_device *dev,
+		 uint8_t func_number,
+		 uint32_t addr,
+		 uint8_t is_write,
+		 caddr_t data, size_t datalen,
+		 uint8_t is_increment,
+		 uint16_t blk_count);
+uint8_t sdio_read_1(struct cam_device *dev, uint8_t func_number, uint32_t addr, int *ret);
+int sdio_write_1(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint8_t val);
+uint16_t sdio_read_2(struct cam_device *dev, uint8_t func_number, uint32_t addr, int *ret);
+int sdio_write_2(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint16_t val);
+uint32_t sdio_read_4(struct cam_device *dev, uint8_t func_number, uint32_t addr, int *ret);
+int sdio_write_4(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint32_t val);
+int sdio_read_bool_for_func(struct cam_device *dev, uint32_t addr, uint8_t func_number, uint8_t *is_enab);
+int sdio_set_bool_for_func(struct cam_device *dev, uint32_t addr, uint8_t func_number, int enable);
+int sdio_is_func_ready(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab);
+int sdio_is_func_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab);
+int sdio_func_enable(struct cam_device *dev, uint8_t func_number, int enable);
+int sdio_is_func_intr_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab);
+int sdio_func_intr_enable(struct cam_device *dev, uint8_t func_number, int enable);
+void sdio_card_reset(struct cam_device *dev);
+uint32_t sdio_get_common_cis_addr(struct cam_device *dev);
+int sdio_func_read_cis(struct cam_device *dev, uint8_t func_number,
+		       uint32_t cis_addr, struct cis_info *info);
+int sdio_card_set_bus_width(struct cam_device *dev, enum mmc_bus_width bw);
diff --git a/usr.bin/sdiotool/linux_compat.h b/usr.bin/sdiotool/linux_compat.h
new file mode 100644
index 00000000000..f9d8dd55132
--- /dev/null
+++ b/usr.bin/sdiotool/linux_compat.h
@@ -0,0 +1,60 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2016-2017 Ilya Bakulin
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#ifndef _LINUX_COMPAT_H_
+#define _LINUX_COMPAT_H_
+
+/* Linux compatibility shims */
+#define uint unsigned int
+#define u32 uint32_t
+#define u8 uint8_t
+#define u16 uint16_t
+#define s32 int32_t
+#define bool int8_t
+#define true 1
+#define false 0
+
+#define usleep_range(a, b) usleep(a)
+#define ENOMEDIUM -1
+#define EINVAL -2
+
+#define WARN_ON(cond) ({                                        \
+      bool __ret = (cond);                                      \
+      if (__ret) {                                              \
+	      printf("WARNING %s failed at %s:%d\n",		\
+		     #cond, __FILE__, __LINE__);	        \
+      }                                                         \
+      (__ret);                                                  \
+})
+
+#endif
diff --git a/usr.bin/sdiotool/linux_sdio_compat.c b/usr.bin/sdiotool/linux_sdio_compat.c
new file mode 100644
index 00000000000..85a0a834716
--- /dev/null
+++ b/usr.bin/sdiotool/linux_sdio_compat.c
@@ -0,0 +1,104 @@
+/*-
+ * Copyright (c) 2016-2017 Ilya Bakulin
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/ioctl.h>
+#include <sys/stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/endian.h>
+#include <sys/sbuf.h>
+#include <sys/mman.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <err.h>
+#include <libutil.h>
+#include <unistd.h>
+
+#include <cam/cam.h>
+#include <cam/cam_debug.h>
+#include <cam/cam_ccb.h>
+#include <cam/mmc/mmc_all.h>
+#include <camlib.h>
+
+#include "linux_compat.h"
+#include "linux_sdio_compat.h"
+#include "cam_sdio.h"
+
+u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret) {
+	return sdio_read_1(func->dev, func->num, addr, err_ret);
+}
+
+unsigned char sdio_f0_readb(struct sdio_func *func, unsigned int addr, int *err_ret) {
+	return sdio_readb(func, addr, err_ret);
+}
+
+u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret) {
+	return sdio_read_2(func->dev, func->num, addr, err_ret);
+}
+
+u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret) {
+	return sdio_read_4(func->dev, func->num, addr, err_ret);
+}
+
+void sdio_writeb(struct sdio_func *func, u8 b,
+		 unsigned int addr, int *err_ret) {
+	*err_ret = sdio_write_1(func->dev, func->num, addr, b);
+}
+
+/* Only writes to the vendor specific CCCR registers
+ * (0xF0 - 0xFF) are permiited. */
+void sdio_f0_writeb(struct sdio_func *func, unsigned char b,
+		    unsigned int addr, int *err_ret)
+{
+	if (addr < 0xF0 || addr > 0xFF) {
+		if (err_ret)
+			*err_ret = -EINVAL;
+		return;
+	}
+	sdio_writeb(func, b, addr, err_ret);
+}
+
+void sdio_writew(struct sdio_func *func, u16 b,
+		 unsigned int addr, int *err_ret) {
+	*err_ret = sdio_write_2(func->dev, func->num, addr, b);
+}
+
+void sdio_writel(struct sdio_func *func, u32 b,
+		 unsigned int addr, int *err_ret) {
+	*err_ret = sdio_write_4(func->dev, func->num, addr, b);
+}
diff --git a/usr.bin/sdiotool/linux_sdio_compat.h b/usr.bin/sdiotool/linux_sdio_compat.h
new file mode 100644
index 00000000000..9236a23eff9
--- /dev/null
+++ b/usr.bin/sdiotool/linux_sdio_compat.h
@@ -0,0 +1,65 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2017 Ilya Bakulin
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#ifndef _LINUX_SDIO_COMPAT_H_
+#define _LINUX_SDIO_COMPAT_H_
+
+#include <sys/types.h>
+#include "linux_compat.h"
+
+/* Linux SDIO stack functions and definitions */
+#define SDIO_CCCR_ABORT SD_IO_CCCR_CTL
+#define SDIO_CCCR_IENx  SD_IO_CCCR_INT_ENABLE
+
+struct sdio_func {
+	struct cam_device *dev;
+	uint8_t num;
+};
+
+u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret);
+unsigned char sdio_f0_readb(struct sdio_func *func,
+			    unsigned int addr, int *err_ret);
+u16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret);
+u32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret);
+
+void sdio_writeb(struct sdio_func *func, u8 b,
+	unsigned int addr, int *err_ret);
+void sdio_f0_writeb(struct sdio_func *func, unsigned char b,
+		    unsigned int addr, int *err_ret);
+void sdio_writew(struct sdio_func *func, u16 b,
+	unsigned int addr, int *err_ret);
+void sdio_writel(struct sdio_func *func, u32 b,
+	unsigned int addr, int *err_ret);
+
+
+#endif
diff --git a/usr.bin/sdiotool/sdiotool.c b/usr.bin/sdiotool/sdiotool.c
new file mode 100644
index 00000000000..f665535bcc3
--- /dev/null
+++ b/usr.bin/sdiotool/sdiotool.c
@@ -0,0 +1,649 @@
+/*-
+ * Copyright (c) 2016-2017 Ilya Bakulin
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/ioctl.h>
+#include <sys/stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/endian.h>
+#include <sys/sbuf.h>
+#include <sys/mman.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <err.h>
+#include <libutil.h>
+#include <unistd.h>
+
+#include <cam/cam.h>
+#include <cam/cam_debug.h>
+#include <cam/cam_ccb.h>
+#include <cam/mmc/mmc_all.h>
+#include <camlib.h>
+
+struct cis_info {
+	uint16_t man_id;
+	uint16_t prod_id;
+	uint16_t max_block_size;
+};
+
+static int sdio_rw_direct(struct cam_device *dev,
+			  uint8_t func_number,
+			  uint32_t addr,
+			  uint8_t is_write,
+			  uint8_t *data,
+			  uint8_t *resp);
+static uint8_t sdio_read_1(struct cam_device *dev, uint8_t func_number, uint32_t addr);
+static void sdio_write_1(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint8_t val);
+static int sdio_is_func_ready(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab);
+static int sdio_is_func_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab);
+static int sdio_func_enable(struct cam_device *dev, uint8_t func_number, int enable);
+static int sdio_is_func_intr_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab);
+static int sdio_func_intr_enable(struct cam_device *dev, uint8_t func_number, int enable);
+static void sdio_card_reset(struct cam_device *dev);
+static uint32_t sdio_get_common_cis_addr(struct cam_device *dev);
+static void probe_bcrm(struct cam_device *dev);
+
+/* Use CMD52 to read or write a single byte */
+int
+sdio_rw_direct(struct cam_device *dev,
+	       uint8_t func_number,
+	       uint32_t addr,
+	       uint8_t is_write,
+	       uint8_t *data, uint8_t *resp) {
+	union ccb *ccb;
+	uint32_t flags;
+	uint32_t arg;
+	int retval = 0;
+
+	ccb = cam_getccb(dev);
+	if (ccb == NULL) {
+		warnx("%s: error allocating CCB", __func__);
+		return (1);
+	}
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(union ccb) - sizeof(struct ccb_hdr));
+
+	flags = MMC_RSP_R5 | MMC_CMD_AC;
+	arg = SD_IO_RW_FUNC(func_number) | SD_IO_RW_ADR(addr);
+	if (is_write)
+		arg |= SD_IO_RW_WR | SD_IO_RW_RAW | SD_IO_RW_DAT(*data);
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_NONE,
+		       /*mmc_opcode*/ SD_IO_RW_DIRECT,
+		       /*mmc_arg*/ arg,
+		       /*mmc_flags*/ flags,
+		       /*mmc_data*/ 0,
+		       /*timeout*/ 5000);
+
+	if (((retval = cam_send_ccb(dev, ccb)) < 0)
+	    || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		const char warnstr[] = "error sending command";
+
+		if (retval < 0)
+			warn(warnstr);
+		else
+			warnx(warnstr);
+		return (-1);
+	}
+
+	*resp = ccb->mmcio.cmd.resp[0] & 0xFF;
+	cam_freeccb(ccb);
+	return (retval);
+}
+
+#if 0
+/*
+ * CMD53 -- IO_RW_EXTENDED
+ * Use to read or write memory blocks
+ *
+ * is_increment=1: FIFO mode
+ * blk_count > 0: block mode
+ */
+int
+sdio_rw_extended(struct cam_device *dev,
+		 uint8_t func_number,
+		 uint32_t addr,
+		 uint8_t is_write,
+		 uint8_t *data, size_t datalen,
+		 uint8_t is_increment,
+		 uint16_t blk_count) {
+	union ccb *ccb;
+	uint32_t flags;
+	uint32_t arg;
+	int retval = 0;
+
+	if (blk_count != 0) {
+		warnx("%s: block mode is not supported yet", __func__);
+		return (1);
+	}
+
+	ccb = cam_getccb(dev);
+	if (ccb == NULL) {
+		warnx("%s: error allocating CCB", __func__);
+		return (1);
+	}
+	bzero(&(&ccb->ccb_h)[1],
+	      sizeof(union ccb) - sizeof(struct ccb_hdr));
+
+	flags = MMC_RSP_R5 | MMC_CMD_AC;
+	arg = SD_IO_RW_FUNC(func_number) | SD_IO_RW_ADR(addr);
+	if (is_write)
+		arg |= SD_IO_RW_WR;
+
+	cam_fill_mmcio(&ccb->mmcio,
+		       /*retries*/ 0,
+		       /*cbfcnp*/ NULL,
+		       /*flags*/ CAM_DIR_NONE,
+		       /*mmc_opcode*/ SD_IO_RW_DIRECT,
+		       /*mmc_arg*/ arg,
+		       /*mmc_flags*/ flags,
+		       /*mmc_data*/ 0,
+		       /*timeout*/ 5000);
+
+	if (((retval = cam_send_ccb(dev, ccb)) < 0)
+	    || ((ccb->ccb_h.status & CAM_STATUS_MASK) != CAM_REQ_CMP)) {
+		const char warnstr[] = "error sending command";
+
+		if (retval < 0)
+			warn(warnstr);
+		else
+			warnx(warnstr);
+		return (-1);
+	}
+
+	*resp = ccb->mmcio.cmd.resp[0] & 0xFF;
+	cam_freeccb(ccb);
+	return (retval);
+}
+#endif
+
+static int
+sdio_read_bool_for_func(struct cam_device *dev, uint32_t addr, uint8_t func_number, uint8_t *is_enab) {
+	uint8_t resp;
+	int ret;
+
+	ret = sdio_rw_direct(dev, 0, addr, 0, NULL, &resp);
+	if (ret < 0)
+		return ret;
+
+	*is_enab = (resp & (1 << func_number)) > 0 ? 1 : 0;
+
+	return (0);
+}
+
+static int
+sdio_set_bool_for_func(struct cam_device *dev, uint32_t addr, uint8_t func_number, int enable) {
+	uint8_t resp;
+	int ret;
+	uint8_t is_enabled;
+
+	ret = sdio_rw_direct(dev, 0, addr, 0, NULL, &resp);
+	if (ret != 0)
+		return ret;
+
+	is_enabled = resp & (1 << func_number);
+	if ((is_enabled !=0 && enable == 1) || (is_enabled == 0 && enable == 0))
+		return 0;
+
+	if (enable)
+		resp |= 1 << func_number;
+	else
+		resp &= ~ (1 << func_number);
+
+	ret = sdio_rw_direct(dev, 0, addr, 1, &resp, &resp);
+
+	return ret;
+}
+
+static uint8_t
+sdio_read_1(struct cam_device *dev, uint8_t func_number, uint32_t addr) {
+	uint8_t val;
+	sdio_rw_direct(dev, func_number, addr, 0, NULL, &val);
+	return val;
+}
+
+__unused static void
+sdio_write_1(struct cam_device *dev, uint8_t func_number, uint32_t addr, uint8_t val) {
+	uint8_t _val;
+	sdio_rw_direct(dev, func_number, addr, 0, &val, &_val);
+}
+
+static int
+sdio_is_func_ready(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab) {
+	return sdio_read_bool_for_func(dev, SD_IO_CCCR_FN_READY, func_number, is_enab);
+}
+
+static int
+sdio_is_func_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab) {
+	return sdio_read_bool_for_func(dev, SD_IO_CCCR_FN_ENABLE, func_number, is_enab);
+}
+
+static int
+sdio_func_enable(struct cam_device *dev, uint8_t func_number, int enable) {
+	return sdio_set_bool_for_func(dev, SD_IO_CCCR_FN_ENABLE, func_number, enable);
+}
+
+static int
+sdio_is_func_intr_enabled(struct cam_device *dev, uint8_t func_number, uint8_t *is_enab) {
+	return sdio_read_bool_for_func(dev, SD_IO_CCCR_INT_ENABLE, func_number, is_enab);
+}
+
+static int
+sdio_func_intr_enable(struct cam_device *dev, uint8_t func_number, int enable) {
+	return sdio_set_bool_for_func(dev, SD_IO_CCCR_INT_ENABLE, func_number, enable);
+}
+
+static int
+sdio_card_set_bus_width(struct cam_device *dev, enum mmc_bus_width bw) {
+	int ret;
+	uint8_t ctl_val;
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_BUS_WIDTH, 0, NULL, &ctl_val);
+	if (ret < 0) {
+		warn("Error getting CCCR_BUS_WIDTH value");
+		return ret;
+	}
+	ctl_val &= ~0x3;
+	switch (bw) {
+	case bus_width_1:
+		/* Already set to 1-bit */
+		break;
+	case bus_width_4:
+		ctl_val |= CCCR_BUS_WIDTH_4;
+		break;
+	case bus_width_8:
+		warn("Cannot do 8-bit on SDIO yet");
+		return -1;
+		break;
+	}
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_BUS_WIDTH, 1, &ctl_val, &ctl_val);
+	if (ret < 0) {
+		warn("Error setting CCCR_BUS_WIDTH value");
+		return ret;
+	}
+	return ret;
+}
+
+static int
+sdio_func_read_cis(struct cam_device *dev, uint8_t func_number,
+		   uint32_t cis_addr, struct cis_info *info) {
+	uint8_t tuple_id, tuple_len, tuple_count;
+	uint32_t addr;
+
+	char *cis1_info[4];
+	int start, i, ch, count;
+	char cis1_info_buf[256];
+
+	tuple_count = 0; /* Use to prevent infinite loop in case of parse errors */
+	memset(cis1_info_buf, 0, 256);
+	do {
+		addr = cis_addr;
+		tuple_id = sdio_read_1(dev, 0, addr++);
+		if (tuple_id == SD_IO_CISTPL_END)
+			break;
+		if (tuple_id == 0) {
+			cis_addr++;
+			continue;
+		}
+		tuple_len = sdio_read_1(dev, 0, addr++);
+		if (tuple_len == 0 && tuple_id != 0x00) {
+			warn("Parse error: 0-length tuple %02X\n", tuple_id);
+			return -1;
+		}
+
+		switch (tuple_id) {
+		case SD_IO_CISTPL_VERS_1:
+			addr += 2;
+			for (count = 0, start = 0, i = 0;
+			     (count < 4) && ((i + 4) < 256); i++) {
+				ch = sdio_read_1(dev, 0, addr + i);
+				printf("count=%d, start=%d, i=%d, Got %c (0x%02x)\n", count, start, i, ch, ch);
+				if (ch == 0xff)
+					break;
+				cis1_info_buf[i] = ch;
+				if (ch == 0) {
+					cis1_info[count] =
+						cis1_info_buf + start;
+					start = i + 1;
+					count++;
+				}
+			}
+			printf("Card info:");
+			for (i=0; i<4; i++)
+				if (cis1_info[i])
+					printf(" %s", cis1_info[i]);
+			printf("\n");
+			break;
+		case SD_IO_CISTPL_MANFID:
+			info->man_id =  sdio_read_1(dev, 0, addr++);
+			info->man_id |= sdio_read_1(dev, 0, addr++) << 8;
+
+			info->prod_id =  sdio_read_1(dev, 0, addr++);
+			info->prod_id |= sdio_read_1(dev, 0, addr++) << 8;
+			break;
+		case SD_IO_CISTPL_FUNCID:
+			/* not sure if we need to parse it? */
+			break;
+		case SD_IO_CISTPL_FUNCE:
+			if (tuple_len < 4) {
+				printf("FUNCE is too short: %d\n", tuple_len);
+				break;
+			}
+			if (func_number == 0) {
+				/* skip extended_data */
+				addr++;
+				info->max_block_size  = sdio_read_1(dev, 0, addr++);
+				info->max_block_size |= sdio_read_1(dev, 0, addr++) << 8;
+			} else {
+				info->max_block_size  = sdio_read_1(dev, 0, addr + 0xC);
+				info->max_block_size |= sdio_read_1(dev, 0, addr + 0xD) << 8;
+			}
+			break;
+		default:
+			printf("Skipping tuple ID %02X len %02X\n", tuple_id, tuple_len);
+		}
+		cis_addr += tuple_len + 2;
+		tuple_count++;
+	} while (tuple_count < 20);
+
+	return 0;
+}
+
+static uint32_t
+sdio_get_common_cis_addr(struct cam_device *dev) {
+	uint32_t addr;
+
+	addr =  sdio_read_1(dev, 0, SD_IO_CCCR_CISPTR);
+	addr |= sdio_read_1(dev, 0, SD_IO_CCCR_CISPTR + 1) << 8;
+	addr |= sdio_read_1(dev, 0, SD_IO_CCCR_CISPTR + 2) << 16;
+
+	if (addr < SD_IO_CIS_START || addr > SD_IO_CIS_START + SD_IO_CIS_SIZE) {
+		warn("Bad CIS address: %04X\n", addr);
+		addr = 0;
+	}
+
+	return addr;
+}
+
+static void sdio_card_reset(struct cam_device *dev) {
+	int ret;
+	uint8_t ctl_val;
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_CTL, 0, NULL, &ctl_val);
+	if (ret < 0)
+		errx(1, "Error getting CCCR_CTL value");
+	ctl_val |= CCCR_CTL_RES;
+	ret = sdio_rw_direct(dev, 0, SD_IO_CCCR_CTL, 1, &ctl_val, &ctl_val);
+	if (ret < 0)
+		errx(1, "Error setting CCCR_CTL value");
+}
+
+/*
+ * How Linux driver works
+ *
+ * The probing begins by calling brcmf_ops_sdio_probe() which is defined as probe function in struct sdio_driver. http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c#L1126
+ *
+ * The driver does black magic by copying func struct for F2 and setting func number to zero there, to create an F0 func structure :)
+ * Driver state changes to BRCMF_SDIOD_DOWN.
+ * ops_sdio_probe() then calls brcmf_sdio_probe() -- at this point it has filled in sdiodev struct with the pointers to all three functions (F0, F1, F2).
+ *
+ * brcmf_sdiod_probe() sets block sizes for F1 and F2. It sets F1 block size to 64 and F2 to 512, not consulting the values stored in SDIO CCCR  / FBR registers!
+ * Then it increases timeout for F2 (what is this?!)
+ * Then it enables F1
+ * Then it attaches "freezer" (without PM this is NOP)
+ * Finally it calls brcmf_sdio_probe() http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L4082
+ *
+ * Here high-level workqueues and sg tables are allocated.
+ * It then calls brcmf_sdio_probe_attach()
+ *
+ * Here at the beginning there is a pr_debug() call with brcmf_sdiod_regrl() inside to addr #define SI_ENUM_BASE            0x18000000.
+ * Return value is 0x16044330.
+ * Then turns off PLL:  byte-write BRCMF_INIT_CLKCTL1 (0x28) ->  SBSDIO_FUNC1_CHIPCLKCSR (0x1000E)
+ * Then it reads value back, should be 0xe8.
+ * Then calls brcmf_chip_attach()
+ *
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c#L1054
+ * This func enumerates and resets all the cores on the dongle.
+ *  - brcmf_sdio_buscoreprep(): force clock to ALPAvail req only:
+ *    SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_ALP_AVAIL_REQ -> SBSDIO_FUNC1_CHIPCLKCSR
+ * Wait up to 15ms to !SBSDIO_ALPAV(clkval) of the value from CLKCSR.
+ * Force ALP:
+ *    SBSDIO_FORCE_HW_CLKREQ_OFF | SBSDIO_FORCE_ALP (0x21)-> SBSDIO_FUNC1_CHIPCLKCSR
+ * Disaable SDIO pullups:
+ * byte 0 -> SBSDIO_FUNC1_SDIOPULLUP (0x0001000f)
+ *
+ *  Calls brcmf_chip_recognition()
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c#L908
+ * Read 0x18000000. Get 0x16044330: chip 4330 rev 4
+ * AXI chip, call  brcmf_chip_dmp_erom_scan() to get info about all cores.
+ * Then  brcmf_chip_cores_check() to check that CPU and RAM are found,
+ *
+ * Setting cores to passive: not clear which of CR4/CA7/CM3 our chip has.
+ *  Quite a few r/w calls to different parts of the chip to reset cores....
+ * Finally get_raminfo() called to fill in RAM info:
+ * brcmf_chip_get_raminfo: RAM: base=0x0 size=294912 (0x48000) sr=0 (0x0)
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c#L700
+ *
+ * Then brcmf_chip_setup() is called, this prints and fills in chipcommon rev and PMU caps:
+ *   brcmf_chip_setup: ccrev=39, pmurev=12, pmucaps=0x19583c0c
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c#L1015
+ *  Bus-specific setup code is NOP for SDIO.
+ *
+ * brcmf_sdio_kso_init() is called.
+ * Here it first reads 0x1 from SBSDIO_FUNC1_SLEEPCSR 0x18000650 and then writes it back... WTF?
+ *
+ * brcmf_sdio_drivestrengthinit() is called
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L3630
+ *
+ * Set card control so an SDIO card reset does a WLAN backplane reset
+ * set PMUControl so a backplane reset does PMU state reload
+ * === end of brcmf_sdio_probe_attach ===
+
+ **** Finished reading at http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c#L4152, line 2025 in the dump
+
+ * === How register reading works ===
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c#L357
+ * The address to read from is written to three byte-sized registers of F1:
+ *  - SBSDIO_FUNC1_SBADDRLOW  0x1000A
+ *  - SBSDIO_FUNC1_SBADDRMID  0x1000B
+ *  - SBSDIO_FUNC1_SBADDRHIGH 0x1000C
+ * If this is 32-bit read , a flag is set. The address is ANDed with SBSDIO_SB_OFT_ADDR_MASK which is 0x07FFF.
+ * Then brcmf_sdiod_regrw_helper() is called to read the reply.
+ * http://lxr.free-electrons.com/source/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c#L306
+ * Based on the address it figures out where to read it from (CCCR / FBR in F0, or somewhere in F1).
+ * Reads are retried three times.
+ * 1-byte IO is done with CMD52, more is read with CMD53 with address increment (not FIFO mode).
+ * http://lxr.free-electrons.com/source/drivers/mmc/core/sdio_io.c#L458
+ * ==================================
+ *
+ *
+ */
+__unused
+static void
+probe_bcrm(struct cam_device *dev) {
+	uint32_t cis_addr;
+	struct cis_info info;
+
+	sdio_card_set_bus_width(dev, bus_width_4);
+	cis_addr = sdio_get_common_cis_addr(dev);
+	printf("CIS address: %04X\n", cis_addr);
+
+	memset(&info, 0, sizeof(info));
+	sdio_func_read_cis(dev, 0, cis_addr, &info);
+	printf("Vendor 0x%04X product 0x%04X\n", info.man_id, info.prod_id);
+}
+__unused
+static uint8_t *
+mmap_fw() {
+	const char fw_path[] = "/home/kibab/repos/fbsd-bbb/brcm-firmware/brcmfmac4330-sdio.bin";
+	struct stat sb;
+	uint8_t *fw_ptr;
+
+	int fd = open(fw_path, O_RDONLY);
+	if (fd < 0)
+		errx(1, "Cannot open firmware file");
+	if (fstat(fd, &sb) < 0)
+		errx(1, "Cannot get file stat");
+	fw_ptr = mmap(NULL, sb.st_size, PROT_READ, 0, fd, 0);
+	if (fw_ptr == MAP_FAILED)
+		errx(1, "Cannot map the file");
+
+	return fw_ptr;
+}
+
+static void
+usage() {
+	printf("sdiotool -u <pass_dev_unit>\n");
+	exit(0);
+}
+
+static void
+get_sdio_card_info(struct cam_device *dev) {
+	uint32_t cis_addr;
+	uint32_t fbr_addr;
+	struct cis_info info;
+
+	cis_addr = sdio_get_common_cis_addr(dev);
+
+	memset(&info, 0, sizeof(info));
+	sdio_func_read_cis(dev, 0, cis_addr, &info);
+	printf("F0: Vendor 0x%04X product 0x%04X max block size %d bytes\n",
+	       info.man_id, info.prod_id, info.max_block_size);
+	for (int i = 1; i <= 2; i++) {
+		fbr_addr = SD_IO_FBR_START * i + 0x9;
+		cis_addr =  sdio_read_1(dev, 0, fbr_addr++);
+		cis_addr |= sdio_read_1(dev, 0, fbr_addr++) << 8;
+		cis_addr |= sdio_read_1(dev, 0, fbr_addr++) << 16;
+		memset(&info, 0, sizeof(info));
+		sdio_func_read_cis(dev, i, cis_addr, &info);
+		printf("F%d: Vendor 0x%04X product 0x%04X max block size %d bytes\n",
+		       i, info.man_id, info.prod_id, info.max_block_size);
+	}
+}
+
+/* Test interrupt delivery when select() */
+__unused static int
+sdio_signal_intr(struct cam_device *dev) {
+	uint8_t resp;
+	int ret;
+
+	ret = sdio_rw_direct(dev, 0, 0x666, 0, NULL, &resp);
+	if (ret < 0)
+		return ret;
+	return (0);
+}
+
+static void
+do_intr_test(__unused struct cam_device *dev) {
+}
+
+int
+main(int argc, char **argv) {
+	char device[] = "pass";
+	int unit = 0;
+	int func = 0;
+	uint8_t resp;
+	uint8_t is_enab;
+	__unused uint8_t *fw_ptr;
+	int ch;
+	struct cam_device *cam_dev;
+	int is_intr_test = 0;
+
+	//fw_ptr = mmap_fw();
+
+	while ((ch = getopt(argc, argv, "Iu:")) != -1) {
+		switch (ch) {
+		case 'u':
+			unit = (int) strtol(optarg, NULL, 10);
+			break;
+		case 'f':
+			func = (int) strtol(optarg, NULL, 10);
+		case 'I':
+			is_intr_test = 1;
+		case '?':
+		default:
+			usage();
+		}
+	}
+	argc -= optind;
+	argv += optind;
+
+	if ((cam_dev = cam_open_spec_device(device, unit, O_RDWR, NULL)) == NULL)
+		errx(1, "Cannot open device");
+
+	get_sdio_card_info(cam_dev);
+	if (is_intr_test > 0)
+		do_intr_test(cam_dev);
+	exit(0);
+	sdio_card_reset(cam_dev);
+
+	/* Read Addr 7 of func 0 */
+	int ret = sdio_rw_direct(cam_dev, 0, 7, 0, NULL, &resp);
+	if (ret < 0)
+		errx(1, "Error sending CAM command");
+	printf("Result: %02x\n", resp);
+
+	/* Check if func 1 is enabled */
+	ret = sdio_is_func_enabled(cam_dev, 1, &is_enab);
+	if (ret < 0)
+		errx(1, "Cannot check if func is enabled");
+	printf("F1 enabled: %d\n", is_enab);
+	ret = sdio_func_enable(cam_dev, 1, 1 - is_enab);
+	if (ret < 0)
+		errx(1, "Cannot enable/disable func");
+	printf("F1 en/dis result: %d\n", ret);
+
+	/* Check if func 1 is ready */
+	ret = sdio_is_func_ready(cam_dev, 1, &is_enab);
+	if (ret < 0)
+		errx(1, "Cannot check if func is ready");
+	printf("F1 ready: %d\n", is_enab);
+
+	/* Check if interrupts are enabled */
+	ret = sdio_is_func_intr_enabled(cam_dev, 1, &is_enab);
+	if (ret < 0)
+		errx(1, "Cannot check if func intr is enabled");
+	printf("F1 intr enabled: %d\n", is_enab);
+	ret = sdio_func_intr_enable(cam_dev, 1, 1 - is_enab);
+	if (ret < 0)
+		errx(1, "Cannot enable/disable func intr");
+	printf("F1 intr en/dis result: %d\n", ret);
+
+	cam_close_spec_device(cam_dev);
+}
-- 
2.16.3

